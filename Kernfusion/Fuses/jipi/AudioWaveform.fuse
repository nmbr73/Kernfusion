--[[--
AudioWaveform

Based on the fuse modifier SuckLessAudioModifier by Pieter Van Houte, this fuse represents the waveform of a PCM 16-bit audio file. The play point is set in the middle of the picture.
There are three parameters for setting the waveform's timing: 1) Proxy 2) Zoom 3) Resolution

1) Proxy: This multiplies the sample pool without increasing the number of pixels shown
2) Zoom: This also multiplies the sample pool, but all values are also displayed (as far as can be displayed)
3) Resolution: Acts as a divisor for the displayable pixels -> Resolution = 2 with HD -> 1920/2

The stereo signal (Both) is generated by maximum formation of the two channels.

After loading the data from file, arrays will be filled with nummerical data. The size of the audio file is limited to 10Mb (from version 0.8 to 50 MB) in order not to make the arrays too large.
The audio data can be moved forward or backward by up to 50 frames.

An amplitude spectrum of the loaded WAV file can be displayed instead of the waveform (control page spectrum)
Attention: The correct settings for the waveform should then be set to 1 for proxy, zoom and resolution. Only then will the FFT display the mathematically correct spectrum.
However, interesting effects can also be achieved with this parameters.
The FFT window is configurable. There are 4 different types of display: raw, bars, smooth and needles.
The support points can be set equidistant. Then sections can be combined, which are also shown in the 4 forms.
The color of the spectrum can be set via the color control page.

If you have selected the display of the spectrum, the "Elongation" functionality can be activated.
A window above the spectrum can be selected here with offset and width. The selected data are calculated with the "Operator" parameter to be set and visualized as a bar.
This value "Elongation" can be used by other nodes by "Connect to".

With the "Steady Waveform" functionality, you can determine how much audio data a so-called seed frame is formed from by selecting the number of frames.
The seed frames are output directly, the "missing" are calculated.

The Samplingdata can be filtered by three frequency bands: Lowpass 0-300 Hz, Bandpass 300 Hz - 3kHz and Highpass 3kHz-20kHz

Elongation can be mapped to On/Off-Values with Hystersis
Elongation for Spectrum has now three Elongations. Each can set to separate Frequencyband with Bandwidth, Offset and Amplify

The Spectrum can be displayed in a colored, mirrored Frequency Visualization ( https://www.shadertoy.com/view/MdVSWG ) Here you can use scale and smooth as parameter

A decompressfeature allowed a spread of the Spectrumdata. With the help of a threshold you can adjust the local minimum and maximum values.


If you like this fuse, I would be happy to receive a message (https://www.steakunderwater.com/wesuckless/memberlist.php?mode=viewprofile&u=4700).
If you can use it very well, it would be great if you supported WSL (https://www.steakunderwater.com).



Versions
0.1 First Try
0.2 Reactor Version
0.3 FFT beta
Implematation of a FFT to show an Equalizer - Test how much Resources and Computingtime is needed
0.4 Amplitude Spectrum
Implementation of Amplitude Spectrum. Choose a frequency band, generate a "modifier" Value for "connect to" functionality
0.5 Beauty Work
Bugfixes: Display Audiodata, SampleRead Stereo, Spectrum vs Waveformenvelope control
Spectrum Appearance: Rough,Bars,Smooth,Needles
0.6 FFT window width selectable (256 - 2048), Scale FFT
Equidistance support points with selectable Steps
FFT Limitation with Compression
0.7 Bugfix: No "Connect to" Data (Elongation), if Fuse not networked
Show Errors in Image: 1) File too large 2) Unsupported WAV-File format
0.8 Optimization of sampleread ( 30% faster )
Elongation for Waveform
Steady Waveform
Filter implemented (LP,BP,HP)
New Controltab:  On/Off Elongation with Hysterese
Change Spectrumvalue to logarithmic
Limitation and Logarithmic is considered for Elongation
0.9 Hide Selection Tool (Elongation)
Smooth Filled for Spectrumsvisualation
BugFix: MapPath
1.0 Additional Error: Wrong bit-depth
Filter/File/Elongationinputs to INP_External = false - avoidance of weird behavior
1.1 Implement of three Elongationsets for Spectrum, added Offset
Bugfix equidistant points
1.2 Add Noisethreshold for Waveform
1.3 Frequency Visualization (Shadertoy) - Interface Audiodata
     - Smoothfunctionality for Frequency Visualization
     - Possibility of multiple use of the FrequencyVisualization in one Composition
    Add Decompressfunctionality in Spectrum(equidistant/logarithmic) with Treshhold
1.4 DCTL corrected
    Added a merge for Backgroundpicture for Frequency Visualization
1.5 Workaround Fusion17 for Waveformdisplay(MoveTo shows line return for normal and positiv envelope)
    Added "Smooth"-Feature for Spectrumdisplay. Falling edges are output with a delay
1.6 Added Slope-Feature - you can choose a corner frequency from which a continuous amplification is carried out, so that high frequencies are raised
    Added a JiPi-Logo
1.7 Bugfix
1.8 Shadertoy Audio
1.9 Creating an 'experimental' variant of this Fuse in 'Kernfusion' to play with


Known Bugs:
If you use the elongation within an expression of another fuse, this is only operated if the AudioWaveform is connected to the active network.
Contrary to the Connect_To functionality. Workaround would be to add an input in the target fuse (edit controls) and fill it with Connect_to,
then an expression can be entered at the target input.

If a image as Input is choosen and the Elongationrectangles in Spectrumpage should be shown, the system crashes.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED.
MAY BE MADE FOR PERSONAL, PRIVATE AND NON-COMMERCIAL USE ONLY.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

--]]--


version = "AudioWaveform V1.9 - 12 Feb 2023"

-- WAV-Daten
sampledata = {}
sampledataleft = {}
sampledataright = {}

FFT_Buffer = {}
local reCalcFootage = false

elongation = 0
elongation2 = 0
elongation3 = 0
elongationhyst = 0
elonmin = 100
elonmax = 0

elon_param = {}
elon_param[0] = {on = 1, bwidth = 0.03, boffset = 0.2, amplify = 1, offset = 0, operator = 0}
elon_param[1] = {on = 0, bwidth = 0.03, boffset = 0.2, amplify = 1, offset = 0, operator = 0}
elon_param[2] = {on = 0, bwidth = 0.03, boffset = 0.2, amplify = 1, offset = 0, operator = 0}
e_sel_old = 0

error_txt = ""



FuRegisterClass("AudioWaveform_jipi", CT_SourceTool, {
  REGS_Name 			  = "Audio Waveform",
  REGS_Category 		  = "Fuses\\Kernfusion\\JiPi",
  REGS_OpDescription 	  = "Audio Waveform ... experimental 'Kernfusion' instance",
  REGS_OpIconString		  = "KAW",
  REG_Fuse_NoEdit         = false,
  REG_Fuse_NoReload       = false,
  REG_Source_GlobalCtrls  = true,
  REG_Source_SizeCtrls	  = true,
  REG_Source_AspectCtrls  = true,
  REG_TimeVariant 		    = true,
  REG_NoPreCalcProcess    = true,  -- call Process for precalc requests (instead of PreCalcProcess)
  REGS_Company 			      = "JiPi",
  REGS_URL 				        = "https://www.steakunderwater.com/wesuckless/",
  REG_Version		          = 000018,
})

-----------------------------------
-- Description of kernel parameters

----------------AudioVisualization---------------
FVParams =
[[
  float fft_data[25];
  float scale;
  float smooth;
  float alpha;
  int cd;
  int width;
  int height;
  float itime;
  int compOrder;
]]

-- source of kernel
FVKernel =
    [[
#define fract(a) a - _floor(a);

//-------corrected pow-function by Chris Ridings--------
__DEVICE__ inline float powcf(float x, float y) {
    float ret = _powf(x,y);
    if (isnan(ret)) {
        ret = 0.0001f;
    }
    return ret;
}
__DEVICE__ float _sign(float value) {
  if (value == 0.0f) return 0.0f;
  return value > 0.0f ? 1.0f : -1.0f;
}
__DEVICE__ float step_base(float edge, float value) {
  return value < edge ? 0.0f : 1.0f;
}
__DEVICE__ float3 step_emu(float3 edge, float3 value) {
  return to_float3(
      step_base(edge.x, value.x),
      step_base(edge.y, value.y),
      step_base(edge.z, value.z));
}
__DEVICE__ float3 pow3f(float3 a, float3 b) {float3 r; r.x = powcf(a.x,b.x); r.y = powcf(a.y,b.y); r.z = powcf(a.z,b.z); return r;}

__DEVICE__ float3 B2_spline(float3 _x) { // returns 3 B-spline functions of degree 2
    float3 t = 3.0f * _x , zero = to_float3_s(0.0f);
    float3 b0 = step_emu(zero, t) * step_emu(zero, 1.0f-t);
    float3 b1 = step_emu(zero, t-1.0f) * step_emu(zero, 2.0f-t);
    float3 b2 = step_emu(zero, t-2.0f) * step_emu(zero, 3.0f-t);
    return 0.5f * (
      b0 * pow3f(t, to_float3_s(2.0f)) +
      b1 * (-2.0f*pow3f(t, to_float3_s(2.0f)) + 6.0f*t - 3.0f) +
      b2 * pow3f(3.0f-t,to_float3_s(2.0f))
    );
}


//############################################################################################################################
__KERNEL__ void FVKernel(__CONSTANTREF__ FVParams *params, __TEXTURE2D__ iChannel0, __TEXTURE2D_WRITE__ dst)
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);
  //---------------------------------------
  if (x < params->width && y < params->height)
  {
    //-----------------------
    float2 fragCoord = to_float2(x, y);
    float2 iResolution = to_float2(params->width, params->height);
    float ratio = (float)params->width/(float)params->height;
    float itime=params->itime;
    float4 fragColor = to_float4_s(0.0f);
    //-----------------------

    // create pixel coordinates
    float2 uv = fragCoord / iResolution;

    float fVBars = 100.0f;
    float fHSpacing = 1.300f;

    float fHFreq = (uv.x * 3.14f);
    float squarewave = _sign(_sinf(fHFreq*fVBars)+1.0f-fHSpacing);

    float _x = _floor(uv.x * fVBars)/fVBars;
    float fSample = 0.0f;

    //-------------------------------------------------------------------------
    //--------------- Interface to Waveform -----------------------------------
    //******* xref ********
    int idx = 6;
    float fft_data[25] = {0.0f};

    #if defined(DEVICE_IS_CUDA)
    static float speicher = 0.05f;
    static float sfft_data[25] = {0.0f};
    #else
    float speicher = 0.05f;
    float sfft_data[25] = {0.0f};
    #endif

    // Bef¸llen des Ausgabearrays
    for (int i=0;i<25;i++)
    {
      if (sfft_data[i]  >  params->fft_data[i])
      {
         if (params->cd) fft_data[i] = sfft_data[i] < params->smooth ? 0.0f : sfft_data[i] - params->smooth;  // constant subside
         else            fft_data[i] = sfft_data[i] - (sfft_data[i]-params->fft_data[i])*params->smooth;      // dynamic subside
      }
      else
         fft_data[i] = params->fft_data[i];
    }


    //********* xref **********
    int xref = (int) ( _floor(_x/2 * fVBars)  ) ;

    if (_x <= 0.49f)
    {
        xref = (int) (24  - _floor((_x+0.02f)/2 * fVBars)  ) +1;
    }
    else
    {
        xref = (int) ( _floor((_x-0.5f-0.01f )/2.0f * fVBars)  )+2 ;
    }
    xref = xref > 24 ? 24 : xref;

    if (y==params->height-1)//(y==1079)
    {
    //speicher = fft_data[15];
    }

    // Bef¸llen des Staticarrays
    if (y==params->height-1)//(y==1079)
    {
      for (int i=0;i<25;i++)
      {
        sfft_data[i] = fft_data[i];
      }
    }


    //----- ‹bergabe ----------
    fSample = fft_data[ xref ];

    //--------------- Interface to Waveform -----------------------------------
    //-------------------------------------------------------------------------
    float fft = squarewave * fSample* params->scale;

    float fHBars = 100.0f;
    float fVSpacing = 0.180f;
    float fVFreq = (uv.y * 3.14f);
    fVFreq = _sign(_sinf(fVFreq * fHBars)+1.0f-fVSpacing);

    float2 centered = to_float2_s(1.0f) * uv - to_float2_s(1.50f);
    float t = itime / 100.0f;
    float polychrome = 1.0f;
    float3 spline_args = fract((polychrome*uv.x-t) + to_float3(0.0f, -1.0f/3.0f, -2.0f/3.0f));
    float3 spline = B2_spline(spline_args);

    float f = _fabs(centered.y);
    float3 base_color  = to_float3(1.0f, 1.0f, 1.0f) - f*spline;
    float3 flame_color = pow3f(base_color, to_float3_s(3.0f));

    float tt = 0.3f - uv.y;
    float df = _sign(tt);
    df = (df + 1.0f)/0.5f;
    float3 col = flame_color * (1.0f - step(fft, _fabs(0.3f-uv.y))) * to_float3_s(fVFreq);
    col -= col * df * 0.180f;

    fragColor = to_float4_aw(col,params->alpha);

    _tex2DVec4Write(dst, x, y, fragColor);
  }
}
]]


-------------------------------------------------------------------
--       Create
-------------------------------------------------------------------
function Create()


  -- Audio File choosing
  InFile = self:AddInput("Wave File", "WaveFile", {
    LINKID_DataType = "Text",
    INPID_InputControl =  "FileControl",
    FC_ClipBrowse = false,				-- true
    INP_DoNotifyChanged  = true,
    INP_External = false,
    FCS_FilterString = "WAV-Files (*.wav)|*.wav|"
  })

  Reload = self:AddInput("Reload Sample", "ReloadSample", {
    INPID_InputControl =  "ButtonControl",
    INP_DoNotifyChanged  = true,
    INP_External = false,
    BTNCS_Execute = "tool.ScriptReload[fu.TIME_UNDEFINED] = 1",
  })

  InChannels = self:AddInput("Select Channel(s)", "SelectChannels", {
    { MBTNC_AddButton = "Left", MBTNCID_AddID = "Left", },
    { MBTNC_AddButton = "Right", MBTNCID_AddID = "Right", },
    { MBTNC_AddButton = "Both", MBTNCID_AddID = "Both", },
    INPID_DefaultID = "Both",
    LINKID_DataType = "FuID",
    INPID_InputControl = "MultiButtonIDControl",
    MBTNC_StretchToFit = true,
    MBTNC_ForceButtons = true,
    IC_Visible = false
  })

  InProxy = self:AddInput("Proxy (for sampling)", "Proxy", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 1,
    INP_MinAllowed = 1,
    INP_MaxScale = 100,
    INP_Default = 25,
    INP_Integer = true,
  })

  InAmplitudeScale = self:AddInput("Amplitude Scale", "AmplitudeScale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    INP_MaxScale = 5,
  })

  InSampleStartFrame = self:AddInput("Sample Start Frame (Time Offset)", "SampleStartFrame", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0,
    INP_MaxScale = 50,
    INP_MinScale = -50,
    INP_MaxAllowed = 50,
    INP_MinAllowed = -50,
    INP_Integer = true,
  })

  InZoom = self:AddInput("Zoom", "Zoom", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 1,
    INP_MinAllowed = 1,
    INP_MaxScale = 100,
    INP_Default = 2,
    INP_Integer = true,
  })

  InResolution = self:AddInput("Resolution", "Resolution", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 1,
    INP_MinAllowed = 1,
    INP_MaxScale = 10,
    INP_Default = 2,
    INP_Integer = true,
  })

  InEnvelopeSel = self:AddInput("Envelope", "EnvelopeSel", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Normal", },
    { CCS_AddString = "Bold", },
    { CCS_AddString = "Special", },
    { CCS_AddString = "Positive", },
    CC_LabelPosition = "Horizontal",
  })


InFiltersOFF = self:AddInput("", "FiltersOFF", {
    { MBTNC_AddButton = "Filter Off", MBTNCID_AddID = "NoFilter", },
    INPID_DefaultID = "NoFilter",
    LINKID_DataType = "FuID",
    INPID_InputControl = "MultiButtonIDControl",
    ICD_Width = 1.0,
    MBTNC_StretchToFit = true,
    MBTNC_ForceButtons = true,
    INP_DoNotifyChanged  = true,
    IC_Visible = true,
    INP_External = false,
    CC_LabelPosition = "Vertical",
  })

InFilters = self:AddInput("", "Filters", {
    { MBTNC_AddButton = "20-300Hz", MBTNCID_AddID = "LP", },
    { MBTNC_AddButton = "300-3kHz", MBTNCID_AddID = "BP", },
    { MBTNC_AddButton = "3-20kHz", MBTNCID_AddID = "HP", },
    INPID_DefaultID = "NoFilter",
    LINKID_DataType = "FuID",
    INPID_InputControl = "MultiButtonIDControl",
    ICD_Width = 1.0,
    MBTNC_StretchToFit = true,
    MBTNC_ForceButtons = true,
    INP_DoNotifyChanged  = true,
    IC_Visible = true,
    INP_External = false,
  })

InNoiseThreshold = self:AddInput("Noise Threshold", "NoiseThreshold", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0,
    INP_MaxScale = 1,
    INP_MinScale = 0,
    INP_MinAllowed = 0.0,
    INP_MaxAllowed = 10000,
    --IC_Visible         = false,
  })


  InCrosshair = self:AddInput("Crosshair", "Crosshair", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0,
  })


  -- Steady Wave
  InSteadyWave = self:AddInput("Steady Wave", "SteadyWave", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    MBTNC_StretchToFit = true,
    INP_Default = 0,
  })


  InFrameCount = self:AddInput("Framecount", "Framecount", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 1,
    INP_MinAllowed = 1,
    INP_MaxScale = 10,
    INP_Default = 1,
    INP_Integer = true,
    IC_Visible  = false,
  })

  --Elongation WF
  InElongationWFOn = self:AddInput("Elongation On", "ElongationWFOn", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged = true,
    INP_Default         = 0,
    IC_Visible          = true,
    INP_External        = false,
  })

  InLabelElongationWF = self:AddInput("Elongation", "LabelElongationWF", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })

  InElongationWFOperation = self:AddInput("Operator", "ElongationWFOperator", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Max", },
    { CCS_AddString = "Average", },
    { CCS_AddString = "Median", },
    CC_LabelPosition = "Horizontal",
    IC_Visible         = false,
  })

   InElongationWFAmplify = self:AddInput("Amplify", "ElongationWFAmplify", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = -4,
    INP_MaxScale = 4,
    INP_Default = 1,
    INP_MinAllowed     = -15,
    INP_MaxAllowed     = 15,
    IC_Visible         = false,
  })

  InElongationWFOffset = self:AddInput("Offset", "ElongationWFOffset", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0,
    INP_MaxScale = 5,
    INP_MinScale = -5,
    INP_MaxAllowed = 10,
    INP_MinAllowed = -10,
    IC_Visible  = false,
  })

  InHideSelectionTool = self:AddInput("Hide Selection Tool", "HideSelectionTool", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    INP_Default = 0,
    IC_Visible           = false,
  })

  -- Shadertoy Audio
  InShadertoyAudio = self:AddInput("Shadertoy Audio", "ShadertoyAudio", {
    LINKID_DataType      = "Number",
    INPID_InputControl   = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    MBTNC_StretchToFit   = true,
    INP_Default = 0,
  })

  InShaderAudioScale = self:AddInput("Shader Audio Scale", "ShaderAudioScale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale     = 0.0,
    --INP_MinAllowed = 1,
    INP_MaxScale     = 2.0,
    INP_Default      = 1.0,
    IC_Visible       = false,
    --INP_Integer = true,
  })


  Sep3 = self:AddInput(string.rep("_", 52), "Separator3", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })

  if (Logo_On) then
    InLogoSw = self:AddInput("Logo", "LogoSw", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
	  INP_Integer         = true,
    INP_DoNotifyChanged = true,
    INP_Default         = 1,
    IC_Visible          = true,
    INP_External        = false,
	  INP_Passive         = true,
  })
  end

  InFileName = self:AddInput("No Audio loaded", "FileName", {
    LINKID_DataType    = "Text",
    INPID_InputControl = "LabelControl",
    INP_External       = false,
    INP_Passive        = true,
    ICD_Width          = 1,
  })


  InLabel = self:AddInput(version, "version", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
    ICD_Width = 1,
  })


  -- Layout --
  self:AddControlPage("Layout")

  self:BeginControlNest("Waveformline", "WFLine", true, {})
  InThickness = self:AddInput("Thickness", "Thickness", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinAllowed     = 0.0001,
    INP_MaxScale       = 0.1,
    INP_Default        = 0.002,
  })

  -- color wheel
  InRed = self:AddInput("Red", "Red", {
    ICS_Name            = "Line Color",
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 1.0,
    INP_MaxScale        = 1.0,
    CLRC_ShowWheel      = false,
    IC_ControlGroup     = 1,
    IC_ControlID        = 0,
  })
  InGreen = self:AddInput("Green", "Green", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 1.0,
    IC_ControlGroup     = 1,
    IC_ControlID        = 1,
  })
  InBlue = self:AddInput("Blue", "Blue", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 1.0,
    IC_ControlGroup     = 1,
    IC_ControlID        = 2,
  })
  InAlpha = self:AddInput("Alpha", "Alpha", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 1.0,
    IC_ControlGroup     = 1,
    IC_ControlID        = 3,
  })
  self:EndControlNest()

  self:BeginControlNest("Crosshairline", "CHLine", true, {})
  InThicknessCH = self:AddInput("Thickness", "ThicknessCH", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinAllowed     = 0.0001,
    INP_MaxScale       = 0.1,
    INP_Default        = 0.002,
  })

  InDotted = self:AddInput("Dotted", "Dotted", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0,
    IC_Visible         = false
  })

  -- color wheel
  InRedCH = self:AddInput("Red", "RedCH", {
    ICS_Name            = "Line Color",
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 1.0,
    INP_MaxScale        = 1.0,
    CLRC_ShowWheel      = false,
    IC_ControlGroup     = 2,
    IC_ControlID        = 0,
  })
  InGreenCH = self:AddInput("GreenCH", "GreenCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 1.0,
    IC_ControlGroup     = 2,
    IC_ControlID        = 1,
  })
  InBlueCH = self:AddInput("BlueCH", "BlueCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 1.0,
    IC_ControlGroup     = 2,
    IC_ControlID        = 2,
  })
  InAlphaCH = self:AddInput("AlphaCH", "AlphaCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 1.0,
    IC_ControlGroup     = 2,
    IC_ControlID        = 3,
  })
  self:EndControlNest()


  -- Spectrum --
  self:AddControlPage("Spectrum")
  InSpectrum = self:AddInput("Spectrum", "Spectrum", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged = true,
    INP_External = false,
    INP_Default = 0,
  })

  DisplayBuffer = self:AddInput("No Data in Buffer", "NoteBuffer", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
    ICD_Width = 1,
    IC_Visible = false
  })

  GenerateBuffer = self:AddInput("Generate Buffer", "GenerateBuffer", {
    LINKS_Name          = "Generate Buffer",
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ButtonControl",
    INP_DoNotifyChanged = true,
    BTNCS_Execute       = NoteWindow,
    ICD_Width           = 1.0,
    IC_Visible          = false
  })


  InFFT = self:AddInput("FFT", "FFT", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "256", },
    { CCS_AddString = "512", },
    { CCS_AddString = "1024", },
    { CCS_AddString = "2048", },
    CC_LabelPosition = "Horizontal",
  })


  InSmoothfactor = self:AddInput("Smooth Factor", "Smoothfactor", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Integer = true,
    INP_MinAllowed = 1,
	  INP_MaxAllowed = 10,
    INP_MinScale = 1,
	  INP_MaxScale = 10,
    INP_Default = 1,
    IC_Visible         = true
  })

  -- Debugging
  InVar1 = self:AddInput("Var1", "Var1", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale     = -1.0,
    --INP_MinAllowed = 1,
    INP_MaxScale     = 1.0,
    INP_Default      = 1.0,
    IC_Visible       = false
    --INP_Integer = true,
  })
  InVar2 = self:AddInput("Var2", "Var2", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = -1,
    --INP_MinAllowed = 1,
    INP_MaxScale = 10.0,
    INP_Default = 2,
    IC_Visible         = false,
    --INP_Integer = true,
  })
  InVar3 = self:AddInput("Var3", "Var3", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = -1,
    --INP_MinAllowed = 1,
    INP_MaxScale = 0.01,
    INP_Default = 1,
    IC_Visible         = false
    --INP_Integer = true,
  })
  InVar4 = self:AddInput("Var4", "Var4", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = -1,
    --INP_MinAllowed = 1,
    INP_MaxScale = 0.01,
    INP_Default = 1,
    IC_Visible         = false,
    --INP_Integer = true,
  })


  InFFTScale = self:AddInput("Scale", "FFTScale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    INP_MaxScale = 10,
    INP_MinScale = 0,
    INP_MinAllowed = 0.01,
    INP_MaxAllowed = 10,
    IC_Visible     = false,
  })

  InLogK = self:AddInput("LogK", "LogK", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Integer    = true,
    INP_MinAllowed = 0,
	  INP_MaxAllowed = 3,
    INP_MinScale   = 0,
	  INP_MaxScale   = 3,
    INP_Default    = 0,
    IC_Visible     = false,
  })


  InAppearance = self:AddInput("Appearance", "Appearance", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Rough", },
    { CCS_AddString = "Bars", },
    { CCS_AddString = "Smooth", },
    { CCS_AddString = "Smooth Filled", },
    { CCS_AddString = "Needles", },
    CC_LabelPosition = "Horizontal",
    IC_Visible     = false,
  })
  --CC_LabelPosition = "Vertical",

  InEquiCuts = self:AddInput("Equidistant Cuts", "EquiCuts", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged = true,
    IC_Visible          = false,
    INP_Default = 0,
  })

  InSteps = self:AddInput("Steps", "Steps", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MinAllowed = 0,
    INP_MaxAllowed = 7,
    --INP_MaxScale = 256,
    INP_Default = 0,
    IC_Visible     = false,
    INP_Integer    = true,
  })
  InLimit = self:AddInput("Limitation", "Limitation", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged = true,
    IC_Visible          = false,
    INP_Default = 0,
  })
  InLimitThreshold = self:AddInput("Threshold", "Threshold", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    INP_MaxScale = 1,
    INP_MinScale = 0.1,
    INP_MinAllowed = 0.0,
    INP_MaxAllowed = 1,
    IC_Visible         = false,
  })
  InLimitCompression = self:AddInput("Compression", "Compression", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 100,
    INP_MaxScale = 100,
    INP_MinScale = 2,
    INP_MinAllowed = 2,
    INP_MaxAllowed = 100,
    IC_Visible         = false,
  })
  InDecompress = self:AddInput("Decompress", "Decompress", {
    LINKID_DataType = "Number",
    INPID_InputControl   = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    INP_Default          = 0,
    IC_Visible           = false,
    INP_External         = true,
  })
  InDCScale = self:AddInput("DC Scale", "DCScale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1.0,
    INP_MaxScale = 1.0,
    INP_MinScale = 0.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    IC_Visible     = false,
  })
  InDCHighLine = self:AddInput("DC HighLine", "DCHighLine", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.5,
    INP_MaxScale = 1.0,
    INP_MinScale = 0.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    IC_Visible     = false,
  })
  InDCThreshold = self:AddInput("DC Threshold", "DCThreshold", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.5,
    INP_MaxScale = 1.0,
    INP_MinScale = 0.0,
    INP_MinAllowed = -1.0,
    INP_MaxAllowed = 1.0,
    IC_Visible     = false,
  })
  InSlope = self:AddInput("Slope", "Slope", {
    LINKID_DataType = "Number",
    INPID_InputControl   = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    INP_Default          = 0,
    IC_Visible           = false,
    INP_External         = true,
  })

  InConerFreq = self:AddInput("Cornerfrequency", "CornerFreq", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.2,
    INP_MaxScale = 1.0,
    INP_MinScale = 0.0,
    INP_MinAllowed = 0.0,
    INP_MaxAllowed = 1.0,
    IC_Visible     = false,
  })
  InSlopeValue = self:AddInput("Slope", "SlopeValue", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.0,
    INP_MaxScale = 20.0,
    INP_MinScale = 0.0,
    INP_MinAllowed = 0.0,
    --INP_MaxAllowed = 1.0,
    IC_Visible     = false,
  })

-----------------------------------------------------------
  Sep1 = self:AddInput(string.rep("_", 52), "Separator1", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })
  InFrequencyVisualization = self:AddInput("FrequencyVisualization", "FrequencyVisualization", {
    LINKID_DataType = "Number",
    INPID_InputControl   = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    INP_Default          = 0,
    IC_Visible           = false,
    INP_External         = false,
  })
  InFVScale = self:AddInput("FV Scale", "FVScale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    INP_MaxScale = 5,
    INP_MinScale = 0,
    INP_MinAllowed = -5.0,
    INP_MaxAllowed = 5.0,
    IC_Visible     = false,
  })
  InFVCD = self:AddInput("Constant", "FVCD", {
    LINKID_DataType = "Number",
    INPID_InputControl   = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    INP_Default          = 1,
    IC_Visible           = false,
    INP_External         = true,
  })

  InFVSmooth = self:AddInput("FV Smooth", "FVSmooth", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.02,
    INP_MaxScale = 0.5,
    INP_MinScale = 0.0,
    INP_MinAllowed = 0.0,
    INP_MaxAllowed = 1.5,
    IC_Visible     = false,
  })

  InFVMerge = self:AddInput("Apply Merge Mode", "ApplyMode", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    { CCS_AddString = "Normal", },
    { CCS_AddString = "Screen", },
    { CCS_AddString = "Dissolve", },
    { CCS_AddString = "Multiply", },
    { CCS_AddString = "Overlay", },
    { CCS_AddString = "Soft Light", },
    { CCS_AddString = "Hard Light", },
    { CCS_AddString = "Color Dodge", },
    { CCS_AddString = "Color Burn", },
    { CCS_AddString = "Darken", },
    { CCS_AddString = "Lighten", },
    { CCS_AddString = "Difference", },
    { CCS_AddString = "Exclusion", },
    { CCS_AddString = "Hue", },
    { CCS_AddString = "Saturation", },
    { CCS_AddString = "Color", },
    { CCS_AddString = "Luminosity",  },
    IC_Visible      = false,
    })


  InBkgAlpha = self:AddInput("Image Alpha", "BkgAlpha", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 1.0,
    INP_MinAllowed     = 0.0,
    IC_Visible         = false,
  })

  InFVAlpha = self:AddInput("FV Alpha", "FVAlpha", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 1.0,
    INP_MinAllowed     = 0.0,
    IC_Visible         = false,
  })


  Sep2 = self:AddInput(string.rep("_", 52), "Separator2", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
    IC_Visible         = false,
  })

  InElongationOn = self:AddInput("Elongation On", "ElongationOn", {
    LINKID_DataType = "Number",
    INPID_InputControl   = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    INP_Default          = 0,
    IC_Visible           = false,
    INP_External         = false,
  })

  InElonSelection = self:AddInput("", "ElonSelection", {
    { MBTNC_AddButton = "E1", MBTNCID_AddID = "E1", },
    { MBTNC_AddButton = "E2", MBTNCID_AddID = "E2", },
    { MBTNC_AddButton = "E3", MBTNCID_AddID = "E3", },
    INPID_DefaultID = "E1",
    LINKID_DataType = "FuID",
    INPID_InputControl = "MultiButtonIDControl",
    ICD_Width = 1.0,
    MBTNC_StretchToFit = true,
    MBTNC_ForceButtons = true,
    INP_DoNotifyChanged  = true,
    IC_Visible = false,
    INP_External = false,
  })

  InEOn = self:AddInput("On", "EOn", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_DoNotifyChanged = false,
    INP_External        = false,  -- don`t allow connections
    --INP_Passive         = true,  -- doesn't affect rendering (doesn't invalidate caches)
    --INP_Active          = false,
    INP_Default         = 1,
    IC_Visible          = false,
  })
  InEOn2 = self:AddInput("On", "EOn2", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_DoNotifyChanged = true,
    INP_External        = false,  -- don`t allow connections
    --INP_Passive         = true,  -- doesn't affect rendering (doesn't invalidate caches)
    --INP_Active          = false,
    INP_Default         = 0,
    IC_Visible          = false,
  })
  InEOn3 = self:AddInput("On", "EOn3", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_DoNotifyChanged = true,
    INP_External        = false,  -- don`t allow connections
    --INP_Passive         = true,  -- doesn't affect rendering (doesn't invalidate caches)
    --INP_Active          = false,
    INP_Default         = 0,
    IC_Visible          = false,
  })

  InLabelElongation = self:AddInput("Elongation", "LabelElongation", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })

  -- Experimental for Expresions (but only activ if showed)
  InElongation = self:AddInput("Elongation", "Elongation", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Disabled        = true,  -- prevent user from dragging preview control
    INP_DoNotifyChanged = false,
    --INP_DoNotifyChanged = false,
    INP_External        = false,  -- don`t allow connections
    INP_Passive         = true,  -- doesn't affect rendering (doesn't invalidate caches)
    IC_Visible          = false,
  })

  -- Parametersets start
  -- Parameterset for Elongation 1
  InRecWidth = self:AddInput("Band Width", "RecWidth", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0.03,
    INP_MinAllowed     = 0.03,
    IC_Visible         = false,
  })

  InRecOffset = self:AddInput("Band Offset", "RecOffset", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0.2,
    INP_MinAllowed     = 0,
    INP_MaxAllowed     = 1,
    IC_Visible         = false,
  })

  InSpectrumZoom = self:AddInput("Zoom", "SpectrumZoom", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    INP_MaxScale = 2,
    INP_MinScale = 1,
    INP_MaxAllowed = 2,
    INP_MinAllowed = 1,
    IC_Visible  = false,
  })

  InElongationAmplify = self:AddInput("Amplify", "ElongationAmplify", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 3,
    INP_Default = 1,
    INP_MinAllowed     = 0,
    --INP_MaxAllowed     = 2,
  })

  InElongationOffset = self:AddInput("Offset", "ElongationOffset", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0,
    INP_MaxScale = 5,
    INP_MinScale = -5,
    INP_MaxAllowed = 10,
    INP_MinAllowed = -10,
    IC_Visible  = false,
  })

  InElongationOperation = self:AddInput("Operator", "ElongationOperator", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Max", },
    { CCS_AddString = "Average", },
    { CCS_AddString = "Median", },
    CC_LabelPosition = "Horizontal",
    IC_Visible         = false,
  })

  -- Parameterset for Elongation2
  InRecWidth2 = self:AddInput("Band Width", "RecWidth2", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0.03,
    INP_MinAllowed     = 0.03,
    IC_Visible         = false,
  })

  InRecOffset2 = self:AddInput("Band Offset", "RecOffset2", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0.2,
    INP_MinAllowed     = 0,
    INP_MaxAllowed     = 1,
    IC_Visible         = false,
  })

  InSpectrumZoom2 = self:AddInput("Zoom", "SpectrumZoom2", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    INP_MaxScale = 2,
    INP_MinScale = 1,
    INP_MaxAllowed = 2,
    INP_MinAllowed = 1,
    IC_Visible  = false,
  })

  InElongationAmplify2 = self:AddInput("Amplify", "ElongationAmplify2", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 3,
    INP_Default = 1,
    INP_MinAllowed     = 0,
    --INP_MaxAllowed     = 2,
    IC_Visible  = false,
  })

  InElongationOffset2 = self:AddInput("Offset", "ElongationOffset2", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0,
    INP_MaxScale = 5,
    INP_MinScale = -5,
    INP_MaxAllowed = 10,
    INP_MinAllowed = -10,
    IC_Visible  = false,
  })

  InElongationOperation2 = self:AddInput("Operator", "ElongationOperator2", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Max", },
    { CCS_AddString = "Average", },
    { CCS_AddString = "Median", },
    CC_LabelPosition = "Horizontal",
    IC_Visible         = false,
  })
  -- Parameterset for Elongation3
  InRecWidth3 = self:AddInput("Band Width", "RecWidth3", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0.03,
    INP_MinAllowed     = 0.03,
    IC_Visible         = false,
  })

  InRecOffset3 = self:AddInput("Band Offset", "RecOffset3", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0.2,
    INP_MinAllowed     = 0,
    INP_MaxAllowed     = 1,
    IC_Visible         = false,
  })

  InSpectrumZoom3 = self:AddInput("Zoom", "SpectrumZoom3", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    INP_MaxScale = 2,
    INP_MinScale = 1,
    INP_MaxAllowed = 2,
    INP_MinAllowed = 1,
    IC_Visible  = false,
  })

  InElongationAmplify3 = self:AddInput("Amplify", "ElongationAmplify3", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0,
    INP_MaxScale = 3,
    INP_Default = 1,
    INP_MinAllowed     = 0,
    --INP_MaxAllowed     = 2,
    IC_Visible  = false,
  })

  InElongationOffset3 = self:AddInput("Offset", "ElongationOffset3", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0,
    INP_MaxScale = 5,
    INP_MinScale = -5,
    INP_MaxAllowed = 10,
    INP_MinAllowed = -10,
    IC_Visible  = false,
  })

  InElongationOperation3 = self:AddInput("Operator", "ElongationOperator3", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Max", },
    { CCS_AddString = "Average", },
    { CCS_AddString = "Median", },
    CC_LabelPosition = "Horizontal",
    IC_Visible         = false,
  })
  --Parametersets end

  InHideSelectionTool2 = self:AddInput("Hide Selection Tool", "HideSelectionTool2", {
    LINKID_DataType = "Number",
    INPID_InputControl   = "CheckboxControl",
    INP_DoNotifyChanged  = true,
    INP_Default          = 0,
    IC_Visible           = false,
  })


-- Layout --
self:AddControlPage("Elongation")

  DisplayNote = self:AddInput("Not available - Elongation off", "Note", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
    ICD_Width = 1,
  })

  InHysterese = self:AddInput("Hysterese", "Hysterese", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged = true,
    IC_Visible          = true,
    INP_Default         = 0,
    INP_External        = false,
    INP_Disabled        = true,  -- prevent user from dragging preview control - only if Elongation is activ
  })

  InSwitchOn = self:AddInput("Switch-On Value", "SwitchOn", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    INP_MaxScale = 5,
    INP_MinScale = -5,
    INP_MaxAllowed = 360,
    INP_MinAllowed = -360,
    --INP_Integer = true,
  })

  InSwitchOff = self:AddInput("Switch-Off Value", "SwitchOff", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0,
    INP_MaxScale = 5,
    INP_MinScale = -5,
    INP_MaxAllowed = 360,
    INP_MinAllowed = -360,
    --INP_Integer = true,
  })

  InElongationDisplay = self:AddInput("Elongation", "DisplayElon", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
    ICD_Width = 1,
  })

  InSwitchOnThr = self:AddInput("Switch-On Threshold", "SwitchOnThr", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.5,
    INP_MaxScale = 5,
    INP_MinScale = 0,
    INP_MaxAllowed = 10,
    INP_MinAllowed = 0,
    --INP_Integer = true,
  })

  InSwitchOffThr = self:AddInput("Switch-Off Threshold", "SwitchOffThr", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.3,
    INP_MaxScale = 5,
    INP_MinScale = 0,
    INP_MaxAllowed = 10,
    INP_MinAllowed = 0,
    --INP_Integer = true,
  })

  DisplayMinMax = self:AddInput("MinMax", "MinMax", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
    ICD_Width = 1,
  })

  -------------------------------------------------------------------
  -- For TextScreen
  -------------------------------------------------------------------
  InFont = self:AddInput("Font", "Font", {
    LINKID_DataType = "Text",
    INPID_InputControl = "FontFileControl",
    IC_ControlGroup = 2,
    IC_ControlID = 0,
    INP_Level = 1,
    INP_DoNotifyChanged = true,
    IC_Visible         = false,
  })

  InFontStyle = self:AddInput("Style", "Style", {
    LINKID_DataType = "Text",
    INPID_InputControl = "FontFileControl",
    IC_ControlGroup = 2,
    IC_ControlID = 1,
    INP_Level = 1,
    INP_DoNotifyChanged = true,
    IC_Visible         = false,
  })

  InPosition = self:AddInput("Position", "Position", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INPID_PreviewControl = "CrosshairControl",
    INP_DoNotifyChanged = true,
    IC_Visible         = false,
  })


  -- In/Out --
  InChannel0 = self:AddInput("iChannel0", "iChannel0", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
    INP_Required = false
  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
    --INP_Required = false
  })

  --Additional Output for Shadertoy
  OutImage2 = self:AddOutput("Output2", "Output2", {
    LINKID_DataType = "Image",
    LINK_Main = 2,
    --INP_Required = false
  })

  OutElongation = self:AddOutput("Elongation", "Elongation", {
    LINKID_DataType = "Number",
  })
  OutElongation2 = self:AddOutput("Elongation2", "Elongation2", {
    LINKID_DataType = "Number",
  })
  OutElongation3 = self:AddOutput("Elongation3", "Elongation3", {
    LINKID_DataType = "Number",
  })

end

-------------------------------------------------------------------
--       NotifyChanged
-------------------------------------------------------------------
Elon = 0
function NotifyChanged(inp, param, time)

  if inp ~= nil and param ~= nil then
    if inp == InFile then
      local filedata = readAll(param.Value)
      if not filedata then
        return
      else
        local header = getHeader(filedata, 104)
        if header[13] == "74" then
          temp_channel = header[59]                -- Junk-Format
        else
          temp_channel = header[23]                -- Wave Format
        end
        sampledatafilter = nil -- Filter data clear
        if temp_channel == "2" then
          InChannels:SetAttrs({IC_Visible = true})
        else
          InChannels:SetAttrs({IC_Visible = false})
        end
      end
    end

    if inp == InEquiCuts then
      if param.Value == 1 then
        InSteps:SetAttrs({IC_Visible = true})
      else
        InSteps:SetAttrs({IC_Visible = false})
      end
    end

    if inp == InLimit then
      if param.Value == 1 then
        InLimitThreshold:SetAttrs({IC_Visible = true})
        InLimitCompression:SetAttrs({IC_Visible = true})
      else
        InLimitThreshold:SetAttrs({IC_Visible = false})
        InLimitCompression:SetAttrs({IC_Visible = false})
      end
    end

    -- Elongation
    if inp == InElongationOn then
      if param.Value == 1 then
        -- Show Controls
        InLabelElongation:SetAttrs({IC_Visible = true})
        --InElongation:SetAttrs({IC_Visible = true})
        InRecWidth:SetAttrs({IC_Visible = true})
        InRecOffset:SetAttrs({IC_Visible = true})
        --InSpectrumZoom:SetAttrs({IC_Visible = true})
        InElongationOperation:SetAttrs({IC_Visible = true})
        InElongationAmplify:SetAttrs({IC_Visible = true})
        InElongationOffset:SetAttrs({IC_Visible = true})
        InHideSelectionTool2:SetAttrs({IC_Visible = true})
        InElonSelection:SetAttrs({IC_Visible = true})
        Elon = 1
        --InEOn:SetAttrs({IC_Visible = true})

        InHysterese:SetAttrs({INP_Disabled = false})
        DisplayNote:SetAttrs({LINKS_Name = "Elongation Spectrum",LBLC_LabelColor = 3,})

        InFrequencyVisualization:SetAttrs({INP_Disabled = true})
      else
        -- Hide Controls
        InLabelElongation:SetAttrs({IC_Visible = false})
        --InElongation:SetAttrs({IC_Visible = false})
        InRecWidth:SetAttrs({IC_Visible = false})
        InRecOffset:SetAttrs({IC_Visible = false})
        InSpectrumZoom:SetAttrs({IC_Visible = false})
        InElongationOperation:SetAttrs({IC_Visible = false})
        InElongationAmplify:SetAttrs({IC_Visible = false})
        InElongationOffset:SetAttrs({IC_Visible = false})

        InRecWidth2:SetAttrs({IC_Visible = false})
        InRecOffset2:SetAttrs({IC_Visible = false})
        InSpectrumZoom2:SetAttrs({IC_Visible = false})
        InElongationOperation2:SetAttrs({IC_Visible = false})
        InElongationAmplify2:SetAttrs({IC_Visible = false})
        InElongationOffset2:SetAttrs({IC_Visible = false})

        InRecWidth3:SetAttrs({IC_Visible = false})
        InRecOffset3:SetAttrs({IC_Visible = false})
        InSpectrumZoom3:SetAttrs({IC_Visible = false})
        InElongationOperation3:SetAttrs({IC_Visible = false})
        InElongationAmplify3:SetAttrs({IC_Visible = false})
        InElongationOffset3:SetAttrs({IC_Visible = false})

        InHideSelectionTool2:SetAttrs({IC_Visible = false})
        InElonSelection:SetAttrs({IC_Visible = false})
        Elon = 0
        InEOn:SetAttrs({IC_Visible = false})
        InEOn2:SetAttrs({IC_Visible = false})
        InEOn3:SetAttrs({IC_Visible = false})

        --ToDo

        InHysterese:SetSource(Number(0),time)
        InHysterese:SetAttrs({INP_Disabled = true})
        DisplayNote:SetAttrs({LINKS_Name = "Not available - Elongation off",LBLC_LabelColor = 2,})

        InFrequencyVisualization:SetAttrs({INP_Disabled = false})
      end
    end

    if inp == InFrequencyVisualization then
      if param.Value == 1 then
        InFVScale:SetAttrs({IC_Visible = true})
        InFVSmooth:SetAttrs({IC_Visible = true})
        InFVCD:SetAttrs({IC_Visible = true})
        InElongationOn:SetAttrs({INP_Disabled = true})
        InFVMerge:SetAttrs({IC_Visible = true})
        InBkgAlpha:SetAttrs({IC_Visible = true})
        InFVAlpha:SetAttrs({IC_Visible = true})
      else
        InFVScale:SetAttrs({IC_Visible = false})
        InFVSmooth:SetAttrs({IC_Visible = false})
        InFVCD:SetAttrs({IC_Visible = false})
        InElongationOn:SetAttrs({INP_Disabled = false})
        InFVMerge:SetAttrs({IC_Visible = false})
        InBkgAlpha:SetAttrs({IC_Visible = false})
        InFVAlpha:SetAttrs({IC_Visible = false})
      end
    end

    if inp == InSpectrum then
      if param.Value == 1 then
        InFFT:SetAttrs({IC_Visible = true})
		    InSmoothfactor:SetAttrs({IC_Visible = true})
        InElongationOn:SetAttrs({IC_Visible = true})
        InFFTScale:SetAttrs({IC_Visible = true})
        InLogK:SetAttrs({IC_Visible = true})
        InAppearance:SetAttrs({IC_Visible = true})
        InEquiCuts:SetAttrs({IC_Visible = true})
        InLimit:SetAttrs({IC_Visible = true})
        InDecompress:SetAttrs({IC_Visible = true})

        if (InDecompress:GetSource(time).Value == 1) then
  		     InDCThreshold:SetAttrs({IC_Visible = true})
           InDCScale:SetAttrs({IC_Visible = true})
           InDCHighLine:SetAttrs({IC_Visible = true})
		    else
           InDCThreshold:SetAttrs({IC_Visible = false})
           InDCScale:SetAttrs({IC_Visible = false})
           InDCHighLine:SetAttrs({IC_Visible = false})
		    end

		    InSlope:SetAttrs({IC_Visible = true})
        if (InSlope:GetSource(time).Value == 1) then
  		     InConerFreq:SetAttrs({IC_Visible = true})
           InSlopeValue:SetAttrs({IC_Visible = true})
		    else
           InConerFreq:SetAttrs({IC_Visible = false})
           InSlopeValue:SetAttrs({IC_Visible = false})
		    end


        InFrequencyVisualization:SetAttrs({IC_Visible = true})
--        InFVMerge:SetAttrs({IC_Visible = true})
--        InBkgAlpha:SetAttrs({IC_Visible = true})
--        InFVAlpha:SetAttrs({IC_Visible = true})
        Sep2:SetAttrs({IC_Visible = true})

        -- Set Standardvalues for real Spectrum
        InProxy:SetSource(Number(1),time)
        InZoom:SetSource(Number(1),time)
        InResolution:SetSource(Number(1),time)

        -- hide Elongation of Waveform
        InElongationWFOn:SetAttrs({IC_Visible = false})
        InElongationWFOn:SetSource(Number(0),time)

      else
        InFFT:SetAttrs({IC_Visible = false})
		    InSmoothfactor:SetAttrs({IC_Visible = false})
        InElongationOn:SetAttrs({IC_Visible = false})
        InFFTScale:SetAttrs({IC_Visible = false})
        InLogK:SetAttrs({IC_Visible = false})
        InAppearance:SetAttrs({IC_Visible = false})
        InEquiCuts:SetAttrs({IC_Visible = false})
        InLimit:SetAttrs({IC_Visible = false})
        InDecompress:SetAttrs({IC_Visible = false})
        InDCThreshold:SetAttrs({IC_Visible = false})
        InDCScale:SetAttrs({IC_Visible = false})
        InDCHighLine:SetAttrs({IC_Visible = false})
        InSlope:SetAttrs({IC_Visible = false})
        InConerFreq:SetAttrs({IC_Visible = false})
        InSlopeValue:SetAttrs({IC_Visible = false})

        InFrequencyVisualization:SetAttrs({IC_Visible = false})
        InFrequencyVisualization:SetSource(Number(0),time)
--        InFVMerge:SetAttrs({IC_Visible = false})
--        InBkgAlpha:SetAttrs({IC_Visible = false})
--        InFVAlpha:SetAttrs({IC_Visible = false})
        Sep2:SetAttrs({IC_Visible = false})

        InEquiCuts:SetSource(Number(0),time)
        InLimit:SetSource(Number(0),time)
        InElongationOn:SetSource(Number(0),time)

        -- show Elongation of Waveform
        InElongationWFOn:SetAttrs({IC_Visible = true})

        InShadertoyAudio:SetSource(Number(0),time)

      end
    end


	  if inp == InDecompress then
      if param.Value == 1 then
           InDCThreshold:SetAttrs({IC_Visible = true})
           InDCScale:SetAttrs({IC_Visible = true})
           InDCHighLine:SetAttrs({IC_Visible = true})
		  else
           InDCThreshold:SetAttrs({IC_Visible = false})
           InDCScale:SetAttrs({IC_Visible = false})
           InDCHighLine:SetAttrs({IC_Visible = false})
		  end
    end

	  if inp == InSlope then
      if param.Value == 1 then
  		  InConerFreq:SetAttrs({IC_Visible = true})
        InSlopeValue:SetAttrs({IC_Visible = true})
		  else
        InConerFreq:SetAttrs({IC_Visible = false})
        InSlopeValue:SetAttrs({IC_Visible = false})
		  end
    end


    if inp == InElonSelection and Elon == 1 then
      if param.Value == "E1" then
        InEOn:SetAttrs({IC_Visible = true})
        InRecWidth:SetAttrs({IC_Visible = true})
        InRecOffset:SetAttrs({IC_Visible = true})
        --InSpectrumZoom:SetAttrs({IC_Visible = true})
        InElongationAmplify:SetAttrs({IC_Visible = true})
        InElongationOffset:SetAttrs({IC_Visible = true})
        InElongationOperation:SetAttrs({IC_Visible = true})

        InEOn2:SetAttrs({IC_Visible = false})
        InRecWidth2:SetAttrs({IC_Visible = false})
        InRecOffset2:SetAttrs({IC_Visible = false})
        InSpectrumZoom2:SetAttrs({IC_Visible = false})
        InElongationAmplify2:SetAttrs({IC_Visible = false})
        InElongationOffset2:SetAttrs({IC_Visible = false})
        InElongationOperation2:SetAttrs({IC_Visible = false})

        InEOn3:SetAttrs({IC_Visible = false})
        InRecWidth3:SetAttrs({IC_Visible = false})
        InRecOffset3:SetAttrs({IC_Visible = false})
        InSpectrumZoom3:SetAttrs({IC_Visible = false})
        InElongationAmplify3:SetAttrs({IC_Visible = false})
        InElongationOffset3:SetAttrs({IC_Visible = false})
        InElongationOperation3:SetAttrs({IC_Visible = false})

      elseif param.Value == "E2" then
        InEOn2:SetAttrs({IC_Visible = true})
        InRecWidth2:SetAttrs({IC_Visible = true})
        InRecOffset2:SetAttrs({IC_Visible = true})
        --InSpectrumZoom2:SetAttrs({IC_Visible = true})
        InElongationAmplify2:SetAttrs({IC_Visible = true})
        InElongationOffset2:SetAttrs({IC_Visible = true})
        InElongationOperation2:SetAttrs({IC_Visible = true})

        InEOn:SetAttrs({IC_Visible = false})
        InRecWidth:SetAttrs({IC_Visible = false})
        InRecOffset:SetAttrs({IC_Visible = false})
        InSpectrumZoom:SetAttrs({IC_Visible = false})
        InElongationAmplify:SetAttrs({IC_Visible = false})
        InElongationOffset:SetAttrs({IC_Visible = false})
        InElongationOperation:SetAttrs({IC_Visible = false})

        InEOn3:SetAttrs({IC_Visible = false})
        InRecWidth3:SetAttrs({IC_Visible = false})
        InRecOffset3:SetAttrs({IC_Visible = false})
        InSpectrumZoom3:SetAttrs({IC_Visible = false})
        InElongationAmplify3:SetAttrs({IC_Visible = false})
        InElongationOffset3:SetAttrs({IC_Visible = false})
        InElongationOperation3:SetAttrs({IC_Visible = false})

      else -- E3
        InEOn3:SetAttrs({IC_Visible = true})
        InRecWidth3:SetAttrs({IC_Visible = true})
        InRecOffset3:SetAttrs({IC_Visible = true})
        --InSpectrumZoom3:SetAttrs({IC_Visible = true})
        InElongationAmplify3:SetAttrs({IC_Visible = true})
        InElongationOffset3:SetAttrs({IC_Visible = true})
        InElongationOperation3:SetAttrs({IC_Visible = true})

        InEOn:SetAttrs({IC_Visible = false})
        InRecWidth:SetAttrs({IC_Visible = false})
        InRecOffset:SetAttrs({IC_Visible = false})
        InSpectrumZoom:SetAttrs({IC_Visible = false})
        InElongationAmplify:SetAttrs({IC_Visible = false})
        InElongationOffset:SetAttrs({IC_Visible = false})
        InElongationOperation:SetAttrs({IC_Visible = false})

        InEOn2:SetAttrs({IC_Visible = false})
        InEOn2:SetAttrs({IC_Visible = false})
        InRecWidth2:SetAttrs({IC_Visible = false})
        InRecOffset2:SetAttrs({IC_Visible = false})
        InSpectrumZoom2:SetAttrs({IC_Visible = false})
        InElongationAmplify2:SetAttrs({IC_Visible = false})
        InElongationOffset2:SetAttrs({IC_Visible = false})
        InElongationOperation2:SetAttrs({IC_Visible = false})
      end
    end

    -- Elongation Waveform
    if inp == InElongationWFOn then
      if param.Value == 1 then
        -- Show Controls
        InLabelElongationWF:SetAttrs({IC_Visible = true})

        InElongationWFAmplify:SetAttrs({IC_Visible = true})
        InElongationWFOperation:SetAttrs({IC_Visible = true})
        InElongationWFOffset:SetAttrs({IC_Visible = true})
        InHideSelectionTool:SetAttrs({IC_Visible = true})

        InHysterese:SetAttrs({INP_Disabled = false})
        DisplayNote:SetAttrs({LINKS_Name = "Elongation Waveform",LBLC_LabelColor = 5,})
      else
        -- Hide
        InLabelElongationWF:SetAttrs({IC_Visible = false})

        InElongationWFAmplify:SetAttrs({IC_Visible = false})
        InElongationWFOperation:SetAttrs({IC_Visible = false})
        InElongationWFOffset:SetAttrs({IC_Visible = false})
        InHideSelectionTool:SetAttrs({IC_Visible = false})

        InHysterese:SetSource(Number(0),time)
        InHysterese:SetAttrs({INP_Disabled = true})
        DisplayNote:SetAttrs({LINKS_Name = "Not available - Elongation off",LBLC_LabelColor = 2,})
      end
    end

    -- Steady Waveform
    if inp == InSteadyWave then
      if param.Value == 1 then
        -- Show Controls
        InFrameCount:SetAttrs({IC_Visible = true})

        --Disable or set Inputs
        InProxy:SetSource(Number(1),time)
        InProxy:SetAttrs({INP_Disabled = true})
        InZoom:SetSource(Number(1),time)
        InZoom:SetAttrs({INP_Disabled = true})
        InResolution:SetSource(Number(1),time)
        InResolution:SetAttrs({INP_Disabled = true})

        -- InAmplitudeScale:SetAttrs({INP_Disabled = true})
        InEnvelopeSel:SetAttrs({INP_Disabled = true})

      else
        -- Hide
        InFrameCount:SetAttrs({IC_Visible = false})

        --enable Inputs
        InProxy:SetAttrs({INP_Disabled = false})
        InZoom:SetAttrs({INP_Disabled = false})
        InResolution:SetAttrs({INP_Disabled = false})

        -- InAmplitudeScale:SetAttrs({INP_Disabled = false})
        InEnvelopeSel:SetAttrs({INP_Disabled = false})
      end
    end

    if inp == GenerateBuffer then
      if (param.Value == 1) then
        -- Generate Buffer
        --table.insert(FFT_Buffer, 0)
        --table.insert(FFT_Buffer[1], 0.9782)
        FFT_Buffer[0] =  0.9782
        reCalcFootage = true
      end
    end

    if inp == InFiltersOFF then
      if param.Value == "NoFilter" then
        InFilters:SetSource(Text("NoFilter"),time)
      end
    end
    if inp == InFilters then
      if param.Value == "LP" or param.Value == "BP" or param.Value == "HP" then
        InFiltersOFF:SetSource(Text("Filter"),time)
      end
    end


    if inp == InShadertoyAudio then
      if param.Value == 1 then
        InSpectrum:SetSource(Number(1),time)
        InSmoothfactor:SetSource(Number(7),time)
        InLogK:SetSource(Number(1),time)
        InShaderAudioScale:SetAttrs({IC_Visible = true})
      else
        InShaderAudioScale:SetAttrs({IC_Visible = false})
      end
    end



	  if (Logo_On) then
		  if inp == InLogoSw then
		    if param.Value == 1 then
			    InLogo:SetAttrs({IC_Visible = true})
		    else
			    InLogo:SetAttrs({IC_Visible = false})
		    end
		  end
    end
  end

  ------------------------ FONT STYLE ---------------------
  if inp == InFont then
    local f = param.Value

    if f == nil or string.len(f) == 0 then
      InFont:SetSource(Text("Open Sans"), time)
    end
  elseif inp == InFontStyle then
    local f = param.Value

    if f == nil or string.len(f) == 0 then
      InFontStyle:SetSource(Text("Regular"), time)
    end
  end
end

-------------------------------------------------------------------
--       PreCalcProcess
-- If not implemented, only the main output will be handled,
-- which would cause tools connected to the Elongation output to fail
-------------------------------------------------------------------
function PreCalcProcess(req)
  -- Attributes for new images
  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = realwidth,
    IMAT_OriginalHeight = realheight,
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
  }

  -- Initialize the images
  local img = Image(imgattrs)

  Process(req)

--InElongationAmplify:SetSource(Number(0),req.time,0)

  -- The attempt to transfer data to other fuses via an input - unfortunately no calculation if AWW is not active and no time-discrete values (no GetValue) -> failed
  InElongation:SetAttrs({INP_Disabled = false})           -- let in anyway :-)
  InElongation:SetSource(Number(elongation),req.Time,0)
  InElongation:SetAttrs({INP_Disabled = true})

  -- set auxilliary output first
  if InEOn:GetValue(req).Value == 1 then
    OutElongation:Set(req, elongation)
  end
  if InEOn2:GetValue(req).Value == 1 then
    OutElongation2:Set(req, elongation2)
  end
  if InEOn3:GetValue(req).Value == 1 then
    OutElongation3:Set(req, elongation3)
  end

  -- output image with no data
  local out = Image({IMG_Like = img, IMG_NoData = true})
  OutImage:Set(req, out)
  OutImage2:Set(req, out)

end


--[[--
function OnConnected(link, old, new)
   if link == InChannel0 then
       print("poop", old, new)
   end
end
--]]--

-- For generating FFT Buffer the User is informed to wait
NoteWindow = [=[
ui = fu.UIManager
disp = bmd.UIDispatcher(ui)
dispmain = bmd.UIDispatcher(ui)

msgbox = disp:AddWindow(
  {
    ID = "Note",
    WindowTitle = "Working...",
    Geometry = { 200,150,400,100 },
    Composition = comp,
    ui:VGroup
    {
      ID = "root",
      ui:HGroup
      {
        Weight = 1,
        ui:Label{ ID="Message", Text = "", Alignment = { AlignHCenter = true, AlignTop = true } }
      },
      ui:HGroup
      {
        Weight = 0,
        ui:Button{ ID = "Close", Text = "Okay" },
      },
    },
  })
msgboxitm = msgbox:GetItems()
function msgbox.On.Close.Clicked(ev)
  disp:ExitLoop()
end
function msgbox.On.Note.Close(ev)
  disp:ExitLoop()
end

function showMessage(str)
  msgboxitm.Message.Text = str
  msgbox:Show()
  disp:RunLoop()
  msgbox:Hide()
end

showMessage("Please be patient -\n  Successful creation is shown in the tool inspector")
]=]


-------------------------------------------------------------------
--       Functions
-------------------------------------------------------------------
-- Get the base filename from a filepath
function GetFilename(mediaDirName)
    local path, basename = string.match(mediaDirName, "^(.+[/\\])(.+)")
    return basename
end

-- function for reading in a binary file
function readAll(file)

  file = self.Comp:MapPath(file)
  local f = io.open(file, "rb")
  if not f then
    if file ~= "" then
      error_txt = "Special Characters in Filename"
    end
    return
  end
  local content = f:read("*all")
  local size = f:seek("end")
  f:close()
  if (size > 52428800) then
    error_txt = "Filesize too large (50 MB)"
    return nil
  else
    if (size < 104) then
      error_txt = "Unsupported WAV-File format"
      return nil
    else
      return content
    end
  end
end

-- function for creating the header table, returns a table
function getHeader(data, length)
  local header = {}
  for pos = 1, length do
    b = string.byte(data, pos) -- create a string one byte long
    table.insert(header, string.format("%i", b))
  end
  return header
end


--function to read a pair of bytes and put them together to form a 16 bit two's complement sample, then return the result converted to decimal numbers
function sampleRead(data, pointer)
  bl = string.byte(data, pointer) -- create a string one byte long
  bh = string.byte(data, pointer+1) -- create a string one byte long

  if bl == nil or bh == nil then
    bl = 0
    bh = 0
  end
  number_int = tonumber(bh) * 256 + tonumber(bl)
  if ( number_int > 32767 )  then -- basically, if the bytelong binary starts with 1
    sample = number_int - 65536
  else
    sample = number_int
  end
  return sample
end

-- #####################################################################
-- function for reading all the required sample data for a given frame, taking into account bitrate and channels (mono,stereo) and returning the result in a table
-- #####################################################################
function getSampleData(filedata, framerate, currenttime, startframe, proxy, zoom, bitrate, resolution, windowwidth, noisethreshold)

  -- Initialize tables needed for WAVE data.
  local sampledata = {}
  local spf = math.floor(bitrate/framerate) -- calculate the amount of samples per frame
  -- create sampledata table for MS WAV (little endian)
  for pos = ((currenttime+startframe)*spf)-(windowwidth*zoom*proxy)/resolution, ((currenttime+startframe)*spf)+(windowwidth*zoom*proxy)/resolution-1, zoom*proxy do
    if (pos < 1) then
      table.insert(sampledata, 0)   -- Data before Startpoint
    else
      zoomdata = {}

      for j = 1,zoom,1 do
        table.insert(zoomdata, filedata[pos+j])

      end
      if (math.abs(getMax(zoomdata)) <= noisethreshold ) then
        table.insert(sampledata,0)
      else
        table.insert(sampledata, getMax(zoomdata) )
      end
    end
  end
  return sampledata
end

-- getSampleData for Display SteadyWave
function getSampleDataSteadyWave(filedata, framerate, currenttime, startframe, proxy, zoom, bitrate, resolution, windowwidth, framecount)

  -- Initialize tables needed for WAVE data.
  local sampledata = {}
  local spf = math.floor(bitrate/framerate) -- calculate the amount of samples per frame

  -- create sampledata table for MS WAV (little endian)
  for pos = (((currenttime+startframe)*spf)-(windowwidth))*framecount/resolution, (((currenttime+startframe)*spf)+(windowwidth))*framecount/resolution-1, framecount  do
    local tmp_data = {}
    for j = 0, framecount-1 do
      if (pos < 1) then
        table.insert(tmp_data, 0)   -- Data before Startpoint
      else
        table.insert(tmp_data, filedata[pos+j])
      end
    end

  table.insert(sampledata, getMax(tmp_data) )
  end
  return sampledata
end

-- ###############################################################################################

-- function for returning the signed maximum of a table
function getMax(data)
  local max = 0
  for i,v in ipairs(data) do
    if math.abs(v) > math.abs(max) then
      max = v
    end
  end
  return max
end

-- function for returning the unsigned maximum of a table
function getUnsignedMax(data)
  local max = 0
  for i,v in ipairs(data) do
    max = math.max(max,math.abs(v))
  end
  return max
end

-- function for returning the signed minimum of a table
function getMin(data)
  local min = 32767
  for i,v in ipairs(data) do
    if math.abs(v) < math.abs(min) then
      min = v
    end
  end
  return min
end

-- function for returning the unsigned minimum of a table
function getUnsignedMin(data)
  local min = 32767
  for i,v in ipairs(data) do
    min = math.min(min,v)
  end
  return min
end

-- function for returning the average of a table
function getAverage(data)
  local sum = 0
  local indices = 0
  for i,v in ipairs(data) do
    sum = sum + v
    indices = indices + 1
  end
  return sum/indices
end

-- function for returning the unsigned average of a table
function getUnsignedAverage(data)
  local sum = 0
  local indices = 0
  for i,v in ipairs(data) do
    sum = sum + math.abs(v)
    indices = indices + 1
  end
  return sum/indices
end

-- function for returning the median of a table
function getMedian(data)
  table.sort(data)
  if #data %2 == 0 then return (data[#data/2] + data[#data/2+1]) / 2 end
  return data[math.ceil(#data/2)]
end

-- function for returning the unsigned median of a table
function getUnsignedMedian(data)
  local unsdata = {}
  for i,v in ipairs(data) do
    unsdata[i] = math.abs(data[i])
  end
  table.sort(unsdata)
  if #unsdata %2 == 0 then return (unsdata[#unsdata/2] + unsdata[#unsdata/2+1]) / 2 end
  return unsdata[math.ceil(#unsdata/2)]
end


---################################# FFT2 ###################################
-- CooleyñTukey FFT algorithm (in-place, divide-and-conquer)
-- ##########################################################################
local komplex = {
  __tostring = function(self) return ("(% .5f % .5fi)"):format(self[1], self[2]) end
}
local A = -2 * math.pi
local function C(t) return setmetatable(t, komplex) end

local function cexp(x)
  local er = math.exp(x[1])
  return C{ er*math.cos(x[2]), er*math.sin(x[2]) }
end

local function cmul(x, y) return C{ x[1]*y[1]-x[2]*y[2], x[1]*y[2]+x[2]*y[1] } end
local function cadd(x, y) return C{ x[1]+y[1], x[2]+y[2] } end
local function csub(x, y) return C{ x[1]-y[1], x[2]-y[2] } end

local function slice(list) -- evens/odds semantics are weird.
  local even, odd = {}, {}
  for i = 1, #list, 2 do even[#even+1] = list[i] end
  for i = 2, #list, 2 do odd[#odd+1] = list[i] end
  return even, odd
end

local function FFT2(x)
  local N, H = #x, math.floor(#x/2)
  local y = {}
  for i = 1, N do
    y[i] = type(x[i]) ~= "table" and C{x[i], 0} or x[i]
  end
  if N <= 1 then return y end
  local evens, odds = slice(y)
  evens = FFT2(evens)
  odds = FFT2(odds)
  local results = {}
  for k = 1, H do
    local T = cexp{0, A*((k-1)/N)}
    results[k] = cadd(evens[k], cmul(T, odds[k]))
    results[H+k] = csub(evens[k], cmul(T, odds[k]))
  end
  return results
end

----------------------------------------------------------------------------------------------------------------------------------------
-- Textscreen
----------------------------------------------------------------------------------------------------------------------------------------
function drawstring(font, style, size, justify, quality, text,x,y)

  local font = TextStyleFont(font, style)
  local tfm = TextStyleFontMetrics(font)
  local line_height = (tfm.TextAscent + tfm.TextDescent + tfm.TextExternalLeading) * 10 * size
  local mat = Matrix4()
  mat:Scale(1.0/tfm.Scale, 1.0/tfm.Scale, 1.0)
  mat:Scale(size, size, 1)

  local  ch, prevch
  local shape = Shape()
  local shh = Shape()
  local x_move = 0
  mat:Move(x,y, 0)

  for line in string.gmatch(text, "%C+") do
    local line_width = 0
    for i=1,#line do
      ch = line:sub(i,i):byte()
      line_width = line_width + tfm:CharacterWidth(ch)*10*size
    end

    if justify == 0 then
    elseif justify == 1 then
      mat:Move(-line_width/2, 0, 0)
    elseif justify == 2 then
      mat:Move(-line_width, 0, 0)
    end

    for i=1,#line do
      prevch = ch
      ch = line:sub(i,i):byte()
      local cw = tfm:CharacterWidth(ch)*10*size

      if prevch then
        x_offset = tfm:CharacterKerning(prevch, ch)*10*size
        x_move = x_move + x_offset
        mat:Move(x_offset, 0, 0)
      end

      mat:Move(cw/2, (-size/2)/2, 0)
      x_move = x_move + cw
      shh = tfm:GetCharacterShape(ch, false)
      shh = shh:TransformOfShape(mat)
      shape:AddShape(shh)
      mat:Move(cw/2, (size/2)/2, 0)
    end
  end
  return shape
end


function note(font,style)
      local p = Pixel({R=0,G=0,B=0,A=1})
      out:Fill(p)

      -- Picture with Text
      local ic = ImageChannel(out, 8)
      local fs = FillStyle()
      local cs = ChannelStyle()
      ic:SetStyleFill(fs)

      --local sh = Shape()
      local shape = {}
      shape = drawstring(font, style, 0.15, 1, 32, "AudioWaveform",0.5,0.4)
      shape2 = drawstring(font, style, 0.1, 1, 32, "Please load Audiofile",0.5,0.2)
      shape:AddShape(shape2)

      ic:ShapeFill(shape)
      if self.Status == "OK" then
        ic:PutToImage("CM_Merge", cs)
      end
      shape3 = drawstring(font, style, 0.1, 1, 32, error_txt,0.5,0.1)
      cs.Color = Pixel({R = 1, G = 0, B = 0, A = 1}) -- Errors are always red
      ic:ShapeFill(shape3)
      if self.Status == "OK" then
         ic:PutToImage("CM_Merge", cs)
      end
      shape4 = drawstring(font, style, 0.05, 1, 32, "https://www.steakunderwater.com",0.5,0.32)
      cs.Color = Pixel({R = 1, G = 0.517647087574, B = 0, A = 1}) -- Orange of WeSuckLess
      ic:ShapeFill(shape4)
      if self.Status == "OK" then
        ic:PutToImage("CM_Merge", cs)
      end
      --OutImage:Set(req, out)
      return out
end

---------------------------- Filterparameter ------------------------------
ACoef_LP200 = {
        0.00000000032922611659,
        0.00000000164613058293,
        0.00000000329226116586,
        0.00000000329226116586,
        0.00000000164613058293,
        0.00000000032922611659
    };
BCoef_LP200 = {
        1.00000000000000000000,
        -4.91528064429013250000,
        9.66470017329030640000,
        -9.50232363808282090000,
        4.67167082038514800000,
        -0.91876669951097933000
    };
-- LP 300Hz 7.Ord SF48kHz
ACoef_LP = {
        0.00000000006703518814,
        0.00000000040221112886,
        0.00000000100552782214,
        0.00000000134070376285,
        0.00000000100552782214,
        0.00000000040221112886,
        0.00000000006703518814
    };

BCoef_LP = {
        1.00000000000000000000,
        -5.84827463755938840000,
        14.25284066648520400000,
        -18.52806916241720000000,
        13.54992717569706400000,
        -5.28563599739811170000,
        0.85921195859450883000
    };
-- LP 300Hz 7.Ord SF44,1kHz
ACoef_LP_SF441 = {
        0.00000000000259980064,
        0.00000000001819860448,
        0.00000000005459581344,
        0.00000000009099302240,
        0.00000000009099302240,
        0.00000000005459581344,
        0.00000000001819860448,
        0.00000000000259980064
    };
BCoef_LP_SF441 = {
        1.00000000000000000000,
        -6.80791785901134630000,
        19.86589231730201300000,
        -32.20956625321428400000,
        31.33774665859004600000,
        -18.29599635868557100000,
        5.93506334776219190000,
        -0.82522185250603020000
    };
-- Lowpass 350Hz 3.Ord
  ACoef = { 0.00049713569693400649,
            0.00099427139386801299,
            0.00049713569693400649
        }

  BCoef = { 1.00000000000000000000,
            -1.93522955470669530000,
            0.93726236021404663000
        }
-- Bandpass 300 Hz - 3 kHz SF48kHz
ACoef_BP = {
        0.00090829569650991858,
        0.00000000000000000000,
        -0.00363318278603967430,
        0.00000000000000000000,
        0.00544977417905951130,
        0.00000000000000000000,
        -0.00363318278603967430,
        0.00000000000000000000,
        0.00090829569650991858
    };
BCoef_BP = {
        1.00000000000000000000,
        -6.93298948274104450000,
        21.11653914618395300000,
        -36.92081966557547900000,
        40.54354964914566000000,
        -28.63942344691590900000,
        12.70999668666855300000,
        -3.24012765338661920000,
        0.36327483676241812000
    };
-- Bandpass 300 Hz - 3 kHz SF44,1kHz
ACoef_BP_SF441 = {
        0.00069797467671760597,
        0.00000000000000000000,
        -0.00279189870687042390,
        0.00000000000000000000,
        0.00418784806030563560,
        0.00000000000000000000,
        -0.00279189870687042390,
        0.00000000000000000000,
        0.00069797467671760597
    };
BCoef_BP_SF441 = {
        1.00000000000000000000,
        -7.02358234906182060000,
        21.65929032920919200000,
        -38.31542884785568500000,
        42.53705327609054600000,
        -30.35252114825823400000,
        13.59549038405866600000,
        -3.49514936184205950000,
        0.39484775452929982000
    };
--Hochpass 3kHz-20kHz
ACoef_HP = {
        0.41465451333867909000,
        -2.90258159337075350000,
        8.70774478011226090000,
        -14.51290796685376900000,
        14.51290796685376900000,
        -8.70774478011226090000,
        2.90258159337075350000,
        -0.41465451333867909000
    };
BCoef_HP = {
        1.00000000000000000000,
        -5.23676986346608690000,
        11.92724341379568600000,
        -15.28401319994014600000,
        11.88274205839911000000,
        -5.59834976602572350000,
        1.47851293295755240000,
        -0.16871780259162930000
    };
--Hochpass 3kHz-20kHz
ACoef_HP_SF441 = {
        0.38132419931998474000,
        -2.66926939523989320000,
        8.00780818571968030000,
        -13.34634697619946700000,
        13.34634697619946700000,
        -8.00780818571968030000,
        2.66926939523989320000,
        -0.38132419931998474000
    };
BCoef_HP_SF441 = {
        1.00000000000000000000,
        -5.08113451743476040000,
        11.26626907336017400000,
        -14.09089291189087400000,
        10.71492099984423000000,
        -4.94613949315266770000,
        1.28179452904199320000,
        -0.14371721711447155000
    };



function iir(data,Aparam,Bparam)

  local datafilter = {}
  local order = #Aparam

  local x = {}
  local y = {}

  for i= 1 ,#Aparam,1 do
    x[i] = 0
    y[i] = 0
  end

  for i = 1, #data,1 do
    --shift the old samples
    for n = order,2, -1 do
      x[n] = x[n-1]
      y[n] = y[n-1]
    end

    --Calculate the new output
    x[1] = data[i]
    y[1] = Aparam[1] * x[1]

    for n=2, order, 1 do
      y[1] = y[1] + Aparam[n] * x[n] - Bparam[n] * y[n]
    end
    table.insert(datafilter,y[1])
  end
  return datafilter
end

local function spline_cubic(y0,y1,y2,y3,mu)
  local mu2 = mu * mu
  local a0 = y3 - y2 - y0 + y1
  local a1 = y0 - y1 - a0
  local a2 = y2 - y0
  local a3 = y1
  return (a0*mu*mu2+a1*mu2+a2*mu+a3)
end

local function spline_catmull_rom(y0,y1,y2,y3,mu)
  local mu2 = mu * mu
  local a0 = -0.5*y0 + 1.5*y1 - 1.5*y2 + 0.5*y3
  local a1 = y0 - 2.5*y1 + 2*y2 - 0.5*y3
  local a2 = -0.5*y0 + 0.5*y2
  local a3 = y1
  return (a0*mu*mu2+a1*mu2+a2*mu+a3)
end


-- Calculate Elongation
function calc_elon(windowwidth,rec_offset,rec_width,data_spektrum,FFTscale,limit,limit_threshold,limit_compression,elongationoperation)
  local band_data = {}

  for i = math.floor(rec_offset*windowwidth)+1, math.floor(rec_offset*windowwidth) + math.floor(rec_width*windowwidth) do
    local k = math.floor(((math.pow(10,i/windowwidth-1)-.1)/0.9)*windowwidth)      -- logarithmic graphs invers
    if k ~= 0 then
      --table.insert(band_data, data_spektrum[k]/10)
      local y = math.log10(data_spektrum[k]* FFTscale+1)

      if limit == 1 then
        if y > limit_threshold then
          local diff = y - limit_threshold
          y = limit_threshold + diff / limit_compression
        end
      end
	    table.insert(band_data, y )
    end
  end

  if elongationoperation == 0 then  -- Max
    elongationPre = getMax(band_data)
  else
    if elongationoperation == 1 then  -- Average
      elongationPre = getAverage(band_data)
    else
      if elongationoperation == 2 then  -- Median
        elongationPre = getMedian(band_data)
      end
    end
  end
  return elongationPre
end
-- $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-------------------------------------------------------------------
--       Process
-------------------------------------------------------------------
local lastreqtime = -2
local lasttime = 0
local last_display_data = {}
local last_elon1_data = 0
local last_elon2_data = 0
local last_elon3_data = 0


function Process(req)
  -- VARIABLES
  --------------------------------------
  -- Build the Image
  --------------------------------------
  local realwidth = Width;
  local realheight = Height;

  -- We'll handle proxy ourselves
  Width = Width / Scale
  Height = Height / Scale
  Scale = 1

  -- Attributes for new images
  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = realwidth,
    IMAT_OriginalHeight = realheight,
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
  }

  -- Second Output for Shadertoy 512*2
  local imgattrs2 = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = 512,
    IMG_Height = 2,
    IMG_Depth  = 8,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = 512,
    IMAT_OriginalHeight = 2,
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
  }

  out2 = Image(imgattrs2)

  -- Initialize the images
  local img = Image(imgattrs)
  local p = Pixel({R=0,G=0,B=0,A=0})
  img:Fill(p) -- Clear the image so the next frame doesn't contain the previous one.

  -- InImage
  if InChannel0:GetValue(req) ~= nil then
    local iimg = InChannel0:GetValue(req)
    out = iimg:CopyOf()     --CopyOf() oder Copy() ?
--    out = Image(imgattrs)
  else
    out = Image(imgattrs)
    local p = Pixel({R=0,G=0,B=0,A=0})
    out:Fill(p)
  end

  -------------------------------------
  --sample 1 processing settings
  --------------------------------------
  local infile = InFile:GetValue(req).Value
  local channelchoice = InChannels:GetValue(req).Value
  local proxy = InProxy:GetValue(req).Value
  --------------------------------------
  local scale = InAmplitudeScale:GetValue(req).Value
  local startframe = InSampleStartFrame:GetValue(req).Value
  --------------------------------------
  local zoom = InZoom:GetValue(req).Value
  local resolution = InResolution:GetValue(req).Value
  local crosshair = InCrosshair:GetValue(req).Value
  local envelopesel = InEnvelopeSel:GetValue(req).Value
  --------------------------------------
  local data_pos = 45

  local currenttime = req.Time -- get the current frame of the comp
  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate") -- get the frame rate of the comp set in the preferences

  --------------------------------------
  local font  	  = InFont:GetValue(req).Value
  local style     = InFontStyle:GetValue(req).Value

  --------------------------------------
  local spectrum     = InSpectrum:GetValue(req).Value
  local spFFT        = (InFFT:GetValue(req).Value + 1)   -- Supportpoints FFT
  local appearance   = InAppearance:GetValue(req).Value
  local equicuts     = InEquiCuts:GetValue(req).Value

  local FFTscale     = InFFTScale:GetValue(req).Value
  local steps        = math.pow(2,InSteps:GetValue(req).Value)

  local limit        = InLimit:GetValue(req).Value
  local limit_threshold = InLimitThreshold:GetValue(req).Value
  local limit_compression = InLimitCompression:GetValue(req).Value

  local windowwidth = 960

  local eon = InElongationOn:GetValue(req).Value == 1
  local eonWF = InElongationWFOn:GetValue(req).Value == 1


  --Debugging
  local var1 =InVar1:GetValue(req).Value
  local var2 =InVar2:GetValue(req).Value
  local var3 =InVar3:GetValue(req).Value
  local var4 =InVar4:GetValue(req).Value

  local ipc = req:IsPreCalc()   -- PreCalc -> Process with NoData Image

  local steadywave = InSteadyWave:GetValue(req).Value == 1

  local noisethreshold = InNoiseThreshold:GetValue(req).Value

  local fft_data = {}    -- ‹bergabearray an DCTL

  -- Precalc only if spectrum or Waveform with elongation
  if (ipc and  not(eon or eonWF)) then
    --print("Process no Calculation")
    return
  end
  --------------------------------------
  ---------- Input WAV-Data ------------
  --------------------------------------
  if not filedata or infiledup ~= infile then -- got to load some audio files to play with :)
    		--print ("loading")
    filedata = readAll(infile)

    if not filedata  then
      print("Please load an audio WAV-File. Size less than 50 MB")
      out = note(font,style)
      OutImage:Set(req, out)
      InFileName:SetAttrs({LINKS_Name = "No Audio loaded",LBLC_LabelColor = 2,})
      return
    else
      infiledup = infile

      --------------------------------------
      -- Read Header
      --------------------------------------
      -- create a table containing the header of the file. This will then be used to get file type, sample rate etc. In wave file the header is stored in the first 44/104 bytes of the file.
      local header = getHeader(filedata, 104) -- Org 44 - Junk 104

      --get some vital information out of the header, to do some form of file format checking
      if header[3] == header[4] and header[17] == "16" then

        bitrate = tonumber(header[26]) * 256 + tonumber(header[25])
        channels = tonumber(header[23])
        bitdepth = tonumber(header[35])
      else
        -- Junk-Format ?
        data_pos = string.find(filedata, "data") -- 4 bytes "data" und 4 byte Size

        if header[13] == "74" and data_pos ~= nil then
          -- Junk-Format

          data_pos = data_pos + 8
          bitrate = tonumber(header[62]) * 256 + tonumber(header[61])
          channels = tonumber(header[59])
          bitdepth = tonumber(header[71])
        else
          print ("Unsupported file type.\nPlease only load of type WAV (Microsoft) signed 16-bit PCM.")
          error_txt = "Unsupported file type"
          InLabel:SetAttrs({LINKS_Name = version,LBLC_LabelColor = 3,})
          infile = ""

          out = note(font,style)
          OutImage:Set(req, out)
          return
        end
      end

      if bitdepth ~= 16 then
        print ("Please only load of type WAV (Microsoft) signed 16-bit PCM.")
        error_txt = "Wrong bit-depth - only 16-bit"
        InLabel:SetAttrs({LINKS_Name = version,LBLC_LabelColor = 3,})
        infile = ""

        out = note(font,style)
        OutImage:Set(req, out)
        return
      end

      InFileName:SetAttrs({LINKS_Name = GetFilename(infiledup),LBLC_LabelColor = 3,})

      -- Audiofile successfull loaded
      frame_number = ((#filedata/2/channels)/bitrate) * self.Comp:GetPrefs("Comp.FrameFormat.Rate")
      fn_str = string.format("Audio(%g kHz) %d frames", bitrate/1000, frame_number)
      InLabel:SetAttrs({LINKS_Name = fn_str,LBLC_LabelColor = 3,})

      error_txt = ""
      --------------------------------------
      -- Fill the sampledata array with the audiodata from File
      --------------------------------------
      -- Clear Samplearrays
      sampledata = {}		-- Mono and both channels
      sampledataleft = {}
      sampledataright = {}

      sampledataLP  = {}
      sampledataBP  = {}
      sampledataHP  = {}

      collectgarbage()

    if (channels == 1) then	-- Monofile
        for x = data_pos, math.min(#filedata,52428800), 2 do
          table.insert(sampledata, sampleRead(filedata, x)/65535)
        end
    else
        for x = data_pos, math.min(#filedata,52428800)-2, 4 do
          left = sampleRead(filedata,x)/65535
          right = sampleRead(filedata, x+2)/65535
          table.insert(sampledataleft, left )
          table.insert(sampledataright, right )

		  if x <= data_pos + 50 then
		     --print( "left", sampleRead(filedata,x), "right", sampleRead(filedata,x+2))
		  end

          if math.abs(left) > math.abs(right) then	-- Stereo(Both) get Maximum
            table.insert(sampledata,left)
          else
            table.insert(sampledata,right)
          end
        end
      end
    end
  end --not filedata or infiledup
--print ("Filel‰nge", #filedata-data_pos)
   --------------------------------------
  --sample 1 processing
  --------------------------------------
  waveform = {}    -- Audiodaten for one Frame
  data_temp = {}   -- Parameterarray

  if channels == 1 or channelchoice == "Both" then
    data_temp = sampledata
  else
    if channelchoice == "Right" then
      data_temp = sampledataleft
    else
      data_temp = sampledataright
    end
  end

  -- Filter
  if InFilters:GetValue(req).Value == "LP" then
    if #sampledataLP == 0 then
      if bitrate == 48000 then
        sampledataLP = iir(sampledata,ACoef_LP,BCoef_LP)
      else
        sampledataLP = iir(sampledata,ACoef_LP_SF441,BCoef_LP_SF441)
      end
    end
    data_temp = sampledataLP

    --[tfir_ini(gw21)]
    --sampledatafilter =  tfir(sampledata,gw21)
  else
    if InFilters:GetValue(req).Value == "BP" then
      if #sampledataBP == 0 then
        if bitrate == 48000 then
          sampledataBP = iir(sampledata,ACoef_BP,BCoef_BP)
        else
          sampledataBP = iir(sampledata,ACoef_BP_SF441,BCoef_BP_SF441)
        end
      end
      data_temp = sampledataBP
    else
      if InFilters:GetValue(req).Value == "HP" then
        if #sampledataHP == 0 then
          if bitrate == 48000 then
            sampledataHP = iir(sampledata,ACoef_HP,BCoef_HP)
          else
            sampledataHP = iir(sampledata,ACoef_HP_SF441,BCoef_HP_SF441)
          end
        end
        data_temp = sampledataHP
      end
    end
  end

  ------------------------------------------------------------------------
  --------------------------- Get Data -----------------------------------
  ------------------------------------------------------------------------
  if spectrum == 1 then
    windowwidth = math.pow(2,spFFT) * 64
    resolution = 1
  end


  if steadywave then
    waveform2 = {}

    framecount = InFrameCount:GetValue(req).Value
    seedframe, subframe = math.modf (currenttime/framecount)

    waveform = getSampleDataSteadyWave(data_temp, framerate, seedframe, startframe, proxy, zoom, bitrate, resolution, windowwidth, framecount)

    if (subframe ~= 0) then

      waveform2 = getSampleDataSteadyWave(data_temp, framerate, seedframe+1, startframe, proxy, zoom, bitrate, resolution, windowwidth, framecount)
      for i = 1, #waveform do
        waveform[i] = (waveform[i] * (1-subframe)) + (waveform2[i] * (subframe))  -- Transfer from one Seedframe to the next
      end
    end
  else
    -- Standard data for Waveform
    waveform = getSampleData(data_temp, framerate, currenttime, startframe, proxy, zoom, bitrate,resolution, windowwidth, noisethreshold)
  end

  if waveform == nil then
    Print ("No Data 2")     -- Maybe never hit
    return
  end

   --------------------------------------
  -- Build the Image
  --------------------------------------
  -- Parameter of the image

  -- Shadertoy-Audio
  pW = Pixel({R = 0.1, G = 0.2, B = 0.3, A = 1}) --Wavepixel
  pS = Pixel({R = 0.1, G = 0.2, B = 0.3, A = 1}) --Spektrumpixel
  shadertoySpec = {}

  local thickness   = InThickness:GetValue(req).Value   --0.002	-- maybe adjustable

  local gain_r 	   = InRed:GetValue(req).Value
  local gain_g     = InGreen:GetValue(req).Value
  local gain_b     = InBlue:GetValue(req).Value
  local gain_a     = InAlpha:GetValue(req).Value
  -- Crosshair
  local thicknessCH  = InThicknessCH:GetValue(req).Value
  local gainCH_r 	 = InRedCH:GetValue(req).Value
  local gainCH_g     = InGreenCH:GetValue(req).Value
  local gainCH_b     = InBlueCH:GetValue(req).Value
  local gainCH_a     = InAlphaCH:GetValue(req).Value

  local ic = ImageChannel(out, 8)
  local fs = FillStyle()
  local cs = ChannelStyle()

  cs.Type = "CT_Image"  --??
  ic:SetStyleFill(fs)

  local x = 0
  local y = 0.5 * (out.Height * out.YScale) / (out.Width * out.XScale)

  local sh = Shape()

  local p = Pixel({A=1})

  local rgb = 1
  local rz = 1
  local gz = 0
  local bz = 0

  local cnt = 0
  --..................................................................
  ------------------------- Display Spectrum -------------------------
  if (spectrum == 1) then
--timestamp = os.clock()
--print ("TimeFFT:", os.clock()-timestamp)
    -- Dataacquise
    sdata = {}
    data_fft = {}

    --FrequencyVisualization
    local ref =  windowwidth/steps/26
    local y_max = 0;

    for i= 1, windowwidth*2 do
      -- Window function
      k = (i - windowwidth)/((windowwidth*2)/math.pi)        -- 256/Pi
      table.insert(sdata, (math.cos(k)*math.cos(k))*waveform[i])
    end

    data_fft = FFT2(sdata)
    data_spektrum = {}

--print ("TimeFFT:", os.clock()-timestamp)

    y=0
	  sh:MoveTo(1,-1)
    sh:LineTo(0,0)
    local x_old = 0  -- Smoothfunction
    local y_old = 0

	display_data = {}
    --------------------------------------------------------------- Equidistant Cuts
    if equicuts == 1 then
      local j = 1

      data_spektrum_max = 0

      -- Amplitudenspektrum
      y = math.sqrt( math.pow( data_fft[1][1], 2) + math.pow (data_fft[1][2], 2) )

      for i=1, windowwidth+1  do
        x = i / windowwidth

        local xlog = j / windowwidth
        local xlog  = math.log10 (xlog*0.9+0.1)+1   -- logarithmic graphs

        data_spektrum[i] = math.sqrt( math.pow( data_fft[i][1], 2) + math.pow (data_fft[i][2], 2) ) --Amplitudenspektrum

        if not ipc then
          data_spektrum_max = 0
          display_data[i] = y


          --#################################################################################################################################################################
          -- Smoothbuffer
          if lasttime == currenttime - 1 then   -- l¸ckenlos letzter frame im Buffer !
            -- Absenkung verlangsamen
            if (y < last_display_data[i]) then
              --display_data[i] = (last_display_data[i] - var1)  -- Variante1: konstante abtrag
              display_data[i] = ( last_display_data[i] - ( last_display_data[i] - y ) / InSmoothfactor:GetValue(req).Value )
            end
          end
          last_display_data[i] = display_data[i]  -- alten Wert speichern

          while x >= xlog do
            j = j + 1
            data_spektrum_max = math.max(math.sqrt( math.pow( data_fft[j][1], 2) + math.pow (data_fft[j][2], 2) ),data_spektrum_max)

            xlog = j / windowwidth
            xlog  = math.log10 (xlog*0.9+0.1)+1
            y = data_spektrum_max
          end
        end
      end

      if not ipc then
        local maxdata = 0

        for i = 1, windowwidth+1, steps do
          x = i/windowwidth -- 1/windowwidth

          if appearance == 0 then   -- rough
            --sh:LineTo(x,y)
          end

          maxdata = 0

          if (i<windowwidth) then
            for k = 0, steps-1 do
              maxdata = math.max(display_data[i+k], maxdata)
            end
          else
            maxdata = display_data[i]
          end

          y = (maxdata * FFTscale/10) * (out.Height * out.YScale) / (out.Width * out.XScale)

          if limit == 1 then
            if y > limit_threshold then
              diff = y - limit_threshold
              y = limit_threshold + diff / limit_compression
            end
          end

          --Slope----------------------------------------------------------------------------
          if (InSlope:GetValue(req).Value == 1) then
            --print("Windowwidth",windowwidth,spFFT,
            if (x > InConerFreq:GetValue(req).Value) then
              y = y * (1+(x - InConerFreq:GetValue(req).Value) * InSlopeValue:GetValue(req).Value)
            end
          end

          --Decompress-----------------------------------------------------------------------
          if (InDecompress:GetValue(req).Value == 1) then
            local dct = InDCThreshold:GetValue(req).Value
            if (y<dct) then
              y = math.max(0, y-(dct-y) * InDCScale:GetValue(req).Value)
            else
              if (y < InDCHighLine:GetValue(req).Value) then
                y = math.min(1.0, y+(y-dct) * InDCScale:GetValue(req).Value )
              end
            end
          end


          if appearance == 0 then   -- rough
  			    sh:LineTo(x,y)
	        else
            if appearance == 4 then -- Needles
              sh:LineTo(x-(1/1920),0)
              sh:LineTo(x,y)
              sh:LineTo(x+(1/1920),0)
            else
              if appearance == 1 then -- Bars
                local rec = Shape()

                rec:AddRectangle(x,x+steps/windowwidth,0,y,0,1)
                cs.Color = Pixel({R = gain_r, G = gain_g, B = gain_b, A = gain_a})
                ic:ShapeFill(rec)
                if self.Status == "OK" then
                  ic:PutToImage("CM_Merge", cs)
                end
              else
                if appearance == 2 or appearance == 3 then   -- smooth
                  for j = x_old, x, 1/1920 do     -- HD ! - Interpolate between the support points
                    q = (j-x_old)/(x-x_old)       -- Beziervariable

                    if y_old < y then
                      -- Rising Values
                      if (j-x_old) < (x-x_old)/2 then
                        y_tmp = y_old + (y-y_old) * (4 * math.pow(q,3))
                      else
                        y_tmp = y_old + (y-y_old) * (1 - math.pow(-2 * q + 2, 3) / 2)
                      end
                    else
                      -- Falling Values
                      if (j-x_old) < (x-x_old)/2 then
                        y_tmp = y_old - (y_old-y) * (4 * math.pow(q,3))
                      else
                        y_tmp = y_old - (y_old-y) * (1 - math.pow(-2 * q + 2, 3) / 2)
                      end
                    end
                    sh:LineTo(j,y_tmp)
                    if appearance == 3 then    --Smooth Filled
                      sh:LineTo(j,0)
                      --sh:MoveTo(j,y_tmp)
                    end
                  end
                  x_old = x
                  y_old = y

                end
              end
            end
          end
 -------------------------------------------------------------------------------------------------------------------------------------
          if (InFrequencyVisualization:GetValue(req).Value == 1) then
            -- Bef¸llen des FFT_data array
            nr = 0
            cnt = cnt + 1
            y_max = math.max(y_max,y);

            if cnt > ref then
                table.insert(fft_data, y)
                cnt = 0
                y_max = 0
                if nr==0 then
                  --print("Array0",y)
                  --nr = 1
                end
            end
          end

        end  -- For i=1 to windowwidth
        if appearance == 4 then -- Needles
          sh:LineTo((1-(1/windowwidth)),0)
          sh:LineTo((1-(1/windowwidth)),y)
        end
      end --ipc
    --********************************************************************************************************************************
    else -- equidistant
      ------------------------------------------------------- Logarithmic
      sh:MoveTo(1,-1)
	    sh:LineTo(0,0)

      sx=0

      for i=1, windowwidth do           -- Show Spectrum
        data_spektrum[i] = math.sqrt( math.pow( data_fft[i][1], 2) + math.pow (data_fft[i][2], 2) ) --Amplitudenspektrum
        if not ipc then
          x = i / windowwidth
          x  = math.log10 (x*0.9+0.1)+1   -- logarithmic graphs

          --ptrS = math.ceil((512-188.9787*math.log10(513-i))*windowwidth/512 )
          ptrS = math.ceil((windowwidth-InVar1:GetValue(req).Value*math.log10(windowwidth+1-i)) )
--print("LogX-Achse: ", i, ptrS)

          -- Appearance of the Spectrum
          if appearance == 1 then   -- bars
            sh:LineTo(x,y)
          end

          --Original
          --y = (math.log10(data_spektrum[i] * FFTscale+1)) * (out.Height * out.YScale) / (out.Width * out.XScale)

          -- Logarithmic
          LogK = math.pow(10,InLogK:GetValue(req).Value)
          --print("Rohwerte: ",data_spektrum[i], math.log10(data_spektrum[i]* FFTscale+1))

          if (InLogK:GetValue(req).Value == 0) then
            specScale = data_spektrum[i] * FFTscale+1
            specScale2 = 1.0
          else
            specScale = data_spektrum[i] * LogK * FFTscale+1
            specScale2 = 1/InLogK:GetValue(req).Value/2
          end

          y = specScale2 * (math.log10(specScale)) * (out.Height * out.YScale) / (out.Width * out.XScale)

		  --#################################################################################################################################################################
          -- Smoothbuffer
          if lasttime == currenttime - 1 then   -- l¸ckenlos letzter frame im Buffer !
           -- Absenkung verlangsamen
            if (y < last_display_data[i]) then
              y = ( last_display_data[i] - ( last_display_data[i] - y ) / InSmoothfactor:GetValue(req).Value )
            end
          end
          last_display_data[i] = y  -- alten Wert speichern

          if limit == 1 then
            if y > limit_threshold then
              diff = y - limit_threshold
              y = limit_threshold + diff / limit_compression
            end
          end

          --Slope----------------------------------------------------------------------------
          if (InSlope:GetValue(req).Value == 1) then
          --print("Windowwidth",windowwidth,spFFT,
            if (x > InConerFreq:GetValue(req).Value) then
              y = y * (1+(x - InConerFreq:GetValue(req).Value) * InSlopeValue:GetValue(req).Value)
            end
          end

          --Decompress-----------------------------------------------------------------------
          if (InDecompress:GetValue(req).Value == 1) then
            local dct = InDCThreshold:GetValue(req).Value
            if (y<dct) then
              y = math.max(0, y-(dct-y) * InDCScale:GetValue(req).Value)
            else
              if (y < InDCHighLine:GetValue(req).Value) then
                y = math.min(1.0, y+(y-dct) * InDCScale:GetValue(req).Value )
              end
            end
          end

          --Shadertoy Audio------------------------------------------------------------------
          for j=0, math.ceil((512/windowwidth))-1 do
  --          print("Start: ",sx,y, (windowwidth~=1024 or i%2) )
            if (windowwidth~=1024 or (i%2) == 1) then -- Pool halbieren
              sx = sx+1
              shadertoySpec[sx] = y
            end
          end

          if appearance == 0 or appearance == 1 then     -- rough
            sh:LineTo(x,y)
          else
            if appearance == 2 or appearance == 3 then   -- smooth
              for j = x_old, x, 1/1920 do     -- HD ! - Interpolate between the support points
                q = (j-x_old)/(x-x_old)       -- Beziervariable

                if y_old < y then
                  -- Rising Values
                  if (j-x_old) < (x-x_old)/2 then
                    y_tmp = y_old + (y-y_old) * (4 * math.pow(q,3))
                  else
                    y_tmp = y_old + (y-y_old) * (1 - math.pow(-2 * q + 2, 3) / 2)
                  end
                else
                  -- Falling Values
                  if (j-x_old) < (x-x_old)/2 then
                    y_tmp = y_old - (y_old-y) * (4 * math.pow(q,3))
                  else
                    y_tmp = y_old - (y_old-y) * (1 - math.pow(-2 * q + 2, 3) / 2)
                  end
                end
                sh:LineTo(j,y_tmp)
                if appearance == 3 then    --Smooth Filled
                  sh:LineTo(j,0)
                end
              end
              x_old = x
              y_old = y

            else
              -- Needles
              sh:LineTo(x-1/1920,0)
              sh:LineTo(x,y)
              sh:LineTo(x+1/1920,0)
            end
          end  -- appearance 2
		    end -- ipc

          -------------------------------------------------------------------------------------------
          if (InFrequencyVisualization:GetValue(req).Value == 1) then
            -- Bef¸llen des FFT_data array
            cnt = cnt + 1
            y_max = math.max(y_max,y);

            if cnt > ref then
              table.insert(fft_data, y)
              cnt = 0
              y_max = 0
            end
          end
       end -- For: show Spectrum Logarithmic
    end -- show Spectrum equidistant

    ----------------- Elongation ----------------------
    if eon then

      e_sel = InElonSelection:GetValue(req).Value
	    smooth =  (lasttime == currenttime - 1)
      --print(lasttime,currenttime, smooth)
      -- Calculate Elongation
      if InEOn:GetValue(req).Value == 1 then
        rec_width = InRecWidth:GetValue(req).Value
        rec_offset = math.min(InRecOffset:GetValue(req).Value, 1 - rec_width)
        elongationoperation = InElongationOperation:GetValue(req).Value

        elongationPre = calc_elon(windowwidth,rec_offset,rec_width,data_spektrum,FFTscale,limit,limit_threshold,limit_compression,elongationoperation, smooth)
        elongationPre1 = elongationPre * InElongationAmplify:GetValue(req).Value + InElongationOffset:GetValue(req).Value -- scale

      -- Smoothbuffer
      if smooth then   -- l¸ckenlos letzter frame im Buffer !
        -- Absenkung verlangsamen
        if (elongationPre1 < last_elon1_data) then
          elongationPre1 = ( last_elon1_data - ( last_elon1_data - elongationPre1 ) / InSmoothfactor:GetValue(req).Value )
          --print("Smooth :", y, last_display_data[i]," diff:", y-last_display_data[i])
        end
      end
      last_elon1_data = elongationPre1  -- alten Wert speichern

      end
      if InEOn2:GetValue(req).Value == 1 then
        rec_width2 = InRecWidth2:GetValue(req).Value
        rec_offset2 = math.min(InRecOffset2:GetValue(req).Value, 1 - rec_width)
        elongationoperation = InElongationOperation2:GetValue(req).Value

        elongationPre = calc_elon(windowwidth,rec_offset2,rec_width2,data_spektrum,FFTscale,limit,limit_threshold,limit_compression,elongationoperation, smooth)
        elongation2 = elongationPre * InElongationAmplify2:GetValue(req).Value + InElongationOffset2:GetValue(req).Value -- scale

      -- Smoothbuffer
      if smooth then   -- l¸ckenlos letzter frame im Buffer !
        -- Absenkung verlangsamen
        if (elongation2 < last_elon2_data) then
          elongation2 = ( last_elon2_data - ( last_elon2_data - elongation2 ) / InSmoothfactor:GetValue(req).Value )
          --print("Smooth :", y, last_display_data[i]," diff:", y-last_display_data[i])
        end
      end
      last_elon2_data = elongation2  -- alten Wert speichern


      end
      if InEOn3:GetValue(req).Value == 1 then
        rec_width3 = InRecWidth3:GetValue(req).Value
        rec_offset3 = math.min(InRecOffset3:GetValue(req).Value, 1 - rec_width)
        elongationoperation = InElongationOperation3:GetValue(req).Value

        elongationPre = calc_elon(windowwidth,rec_offset3,rec_width3,data_spektrum,FFTscale,limit,limit_threshold,limit_compression,elongationoperation, smooth)
        elongation3 = elongationPre * InElongationAmplify3:GetValue(req).Value + InElongationOffset3:GetValue(req).Value -- scale

      -- Smoothbuffer
      if smooth then   -- l¸ckenlos letzter frame im Buffer !
        -- Absenkung verlangsamen
        if (elongation3 < last_elon3_data) then
          elongation3 = ( last_elon3_data - ( last_elon3_data - elongation3 ) / InSmoothfactor:GetValue(req).Value )
          --print("Smooth :", y, last_display_data[i]," diff:", y-last_display_data[i])
        end
      end
      last_elon3_data = elongation3  -- alten Wert speichern

    end

      -- Show Selectiontool
      if e_sel == "E1" then
        e_col = {R = 1, G = 0.425, B = 0, A = 1} -- lovley orange
        elon_display = elongationPre1
      elseif e_sel == "E2" then
        e_col = {R = 1, G = 0.425, B = 1, A = 1}  -- lovley pink
        rec_width = rec_width2
        rec_offset = rec_offset2
        elon_display = elongation2
      else              -- E3
        e_col = {R = 0.425, G = 0.425, B = 0, A = 1}  -- lovley green
        rec_width = rec_width3
        rec_offset = rec_offset3
        elon_display = elongation3
      end

      -- Display Elongationband
      if (InEOn:GetValue(req).Value == 1 and e_sel == "E1") or (InEOn2:GetValue(req).Value == 1 and e_sel == "E2") or (InEOn3:GetValue(req).Value == 1 and e_sel == "E3") then

          if InHideSelectionTool2:GetValue(req).Value == 0 then
          --print("Offset",rec_offset)
          local rec= Shape()
          rec:AddRectangle(rec_offset + rec_width,rec_offset,0,0.57,0,1)
          cs.Color = Pixel(e_col)
          ic:ShapeFill(rec)
          if self.Status == "OK" then
            ic:PutToImage("CM_Merge", cs)
          end

          local rec2= Shape()
          rec2:AddRectangle(rec_offset + rec_width,rec_offset,0,elon_display,0,1)
          cs.Color = Pixel({R = 0.5, G = 0.05, B = 0.05, A = 1}) -- lovley red
          ic:ShapeFill(rec2)
          if self.Status == "OK" then
            ic:PutToImage("CM_Merge", cs)
          end
        end

        lb_str = (string.format("Elongation   %g",elon_display))
        InLabelElongation:SetAttrs({LINKS_Name = lb_str,LBLC_LabelColor = 1,})
      else
        lb_str = "No Elongation activ"
        InLabelElongation:SetAttrs({LINKS_Name = lb_str,LBLC_LabelColor = 2,})
      end

      elongationPre = elongationPre1

      -- Serve the additional Outputs
      if InEOn2:GetValue(req).Value == 1 then
        OutElongation2:Set(req, elongation2)
      end
      if InEOn3:GetValue(req).Value == 1 then
        OutElongation3:Set(req, elongation3)
      end
    end
  else --end show Spectrum

    ----------------------------------------------------------------
    -- Elongation Waveform
    -- -------------------------------------------------------------
    local modeWF     = InElongationWFOperation:GetValue(req).Value  -- Operation
    local offsetWF   = InElongationWFOffset:GetValue(req).Value     -- offset
    local scaleWF    = 2*InElongationWFAmplify:GetValue(req).Value  -- scale

    inv = 1
    data_temp = {}

    -- Only the half of displayed Data for elongation
    for i=#waveform/2 - #waveform/4, #waveform/2 + #waveform/4 do
      table.insert(data_temp, waveform[i])
    end

    --ToDo for performance: Calculation of values can be done in the "for loop" without calling a function
    if eonWF then
      if modeWF == 0 then -- MAX
        elongationPre = math.max(offsetWF + (inv*getUnsignedMax(data_temp))*scaleWF,0)
      elseif modeWF == 1 then -- Average
        elongationPre = math.max(offsetWF + (inv*getUnsignedAverage(data_temp))*scaleWF,0)
      elseif modeWF == 2 then -- Median
        elongationPre = math.max(offsetWF + (inv*getUnsignedMedian(data_temp))*scaleWF,0)
      end

      lb_str = (string.format("Elongation   %g",elongationPre))
      InLabelElongationWF:SetAttrs({LINKS_Name = lb_str,LBLC_LabelColor = 1,})

      if not ipc and InHideSelectionTool:GetValue(req).Value == 0 then
        local rec3= Shape()
        elongation_norm = elongation * (out.Height * out.YScale) / (out.Width * out.XScale)
        rec3:AddRectangle(0.25,0.75,0,elongation_norm,0,1)      -- Elongation refers to half of the displayed values, in the middle of the display
        cs.Color = Pixel({R = 0.5, G = 0.05, B = 0.05, A = 1})  -- lovley red
        ic:ShapeFill(rec3)
        if self.Status == "OK" then
          ic:PutToImage("CM_Merge", cs)
        end
      end
    end

    ----------------------------------------------------------------
    ------------------ Waveform Displayvariations ------------------
    ----------------------------------------------------------------
    --sh:LineTo(1.5,1.5)   -- Workaround for Fusion17
	  --sh:LineTo(-0.1,1.5)
	  --sh:MoveTo(0,0)
    if not ipc then

      if envelopesel == 3 then   -- Positive
        ----------- Standard Waveformcurve ------------
        for i=1,(1920/resolution)-1 do
		      sh:MoveTo(x,y)  -- Fusion17 workaround
          x = (i)/(1920/resolution)
          y = math.abs((waveform[i] * scale)) * (out.Height * out.YScale) / (out.Width * out.XScale)

          sh:LineTo(x,y)
        end

      else
        if envelopesel == 1 then
          -- Envelopecurve Variation 1: Bold
          for i=1,(1920/resolution)-1 do
            x = (i)/(1920/resolution)
            y = (0.5 + waveform[i] * scale) * (out.Height * out.YScale) / (out.Width * out.XScale)
            sh:MoveTo(x,y)

            y = (0.5 + -waveform[i] * scale) * (out.Height * out.YScale) / (out.Width * out.XScale)
            sh:LineTo(x,y)
          end
        else
          if envelopesel == 2 then
            -- Envelopecurve Variation 2: Special
            for i=1,(1920/resolution)-1 do
              x = (i)/(1920/resolution)
              y = (0.5 + waveform[i] * waveform[i] * waveform[i] * scale) * (out.Height * out.YScale) / (out.Width * out.XScale)

              sh:MoveTo(x,y)
              y = (0.5 - waveform[i] * waveform[i] * waveform[i] * scale) * (out.Height * out.YScale) / (out.Width * out.XScale)
              sh:LineTo(x,y)
            end
          else
            if envelopesel == 0 then
              ----------- Standard Waveformcurve ------------
              for i=1,(1920/resolution)-1 do
				        sh:MoveTo(x,y)  -- Fusion17 workaround
                x = (i)/(1920/resolution)
                y = (0.5 + waveform[i] * scale) * (out.Height * out.YScale) / (out.Width * out.XScale)
                sh:LineTo(x,y)
              end
            else
              -- Erweiterungen
              print("not yet implemented")
                            -- Surprise

            end	-- Standard
          end -- Special
        end	-- Bold
      end -- Positive
    end -- IPC     --	print ("WaveformData: ",#waveform," y: ",y, " x: ",x)
  end --Spectrum/Waveform



  sh = sh:OutlineOfShape(thickness, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)
  -- put shape to image
  cs.Color = Pixel({R = gain_r, G = gain_g, B = gain_b, A = gain_a})
  ic:ShapeFill(sh)

  if self.Status == "OK" then
    ic:PutToImage("CM_Merge", cs)
  end

  -- Elongation as Hysterese Output
  if (eon or eonWF) then

    if (InHysterese:GetValue(req).Value == 1) then
      if elongationPre >= InSwitchOnThr:GetValue(req).Value then
        elongationhys = InSwitchOn:GetValue(req).Value
      else
        if elongationPre <= InSwitchOffThr:GetValue(req).Value then
          elongationhys = InSwitchOff:GetValue(req).Value
        end
      end

      if elongationPre < elonmin then
        elonmin = elongationPre
      end

      if elongationPre > elonmax then
        elonmax = elongationPre
      end

      lb_str = (string.format("Min: %g  Max: %g",elonmin,elonmax))
      DisplayMinMax:SetAttrs({LINKS_Name = lb_str,LBLC_LabelColor = 1,})

      elongation = elongationhys

      lb_str = (string.format("Elongation %g (%g)",elongation, elongationPre))
      InElongationDisplay:SetAttrs({LINKS_Name = lb_str,LBLC_LabelColor = 1,})
    else
      elonmin=100
      elonmax=0

      elongation = elongationPre
    end

    -- set auxilliary output first
    -- OutElongation:Set(req, InElongation:GetValue(req))
    OutElongation:Set(req, elongation)
  end



  -- Show Crosshair
  if crosshair == 1 then
    local x = 0
    local y = 0.5 * (out.Height * out.YScale) / (out.Width * out.XScale)

    local ch = Shape()

    ch:MoveTo(0.5,0)
    ch:LineTo(0.5,1*(out.Height * out.YScale) / (out.Width * out.XScale))

    ch:MoveTo(0,0.5 *(out.Height * out.YScale) / (out.Width * out.XScale))
    ch:LineTo(1,0.5 *(out.Height * out.YScale) / (out.Width * out.XScale))

    ch = ch:OutlineOfShape(thicknessCH, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)
    cs.Color = Pixel({R = gainCH_r, G = gainCH_g, B = gainCH_b, A = gainCH_a})
    ic:ShapeFill(ch)
    if self.Status == "OK" then
      ic:PutToImage("CM_Merge", cs)
    end
  end




  ----------------------------------------------------------------
  ----------------- DCTL Frequency Visualization -----------------
  ----------------------------------------------------------------
  if (InFrequencyVisualization:GetValue(req).Value == 1) then

    local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate") -- get the frame rate of the comp set in the preferences

    local nodeName = self.Name
    FVKernel = string.gsub(FVKernel, "FVKernel", nodeName)
    node = DVIPComputeNode(req, nodeName, FVKernel, "FVParams", FVParams)

    --if (lastreqtime ~= req.Time - 1) then -- Use, if CT_Tool
    --  params = node:GetParamBlock(FVParams)
    --end
    --lastreqtime = req.Time

    if not pcall(function ()
      params.fft_data = {fft_data[1],fft_data[2],fft_data[3],fft_data[4],fft_data[5],fft_data[6],fft_data[7],fft_data[8],fft_data[9],fft_data[10],fft_data[11],fft_data[12],fft_data[13],fft_data[14],fft_data[15],fft_data[16],fft_data[17],fft_data[18],fft_data[19],fft_data[20],fft_data[21],fft_data[22],fft_data[23],fft_data[24],fft_data[25]}
      params.scale = InFVScale:GetValue(req).Value
      params.smooth = InFVSmooth:GetValue(req).Value
      params.cd     = InFVCD:GetValue(req).Value
      params.alpha  = InFVAlpha:GetValue(req).Value
      params.compOrder = 15                   -- params.srcCompOrder = src:IsMask() and 1 or 15
      params.width  = img.DataWindow:Width()
      params.height = img.DataWindow:Height()
      params.itime = req.Time / framerate
      node:SetParamBlock(params)
    end) then
      params = node:GetParamBlock(FVParams)
      params.fft_data = {fft_data[1],fft_data[2],fft_data[3],fft_data[4],fft_data[5],fft_data[6],fft_data[7],fft_data[8],fft_data[9],fft_data[10],fft_data[11],fft_data[12],fft_data[13],fft_data[14],fft_data[15],fft_data[16],fft_data[17],fft_data[18],fft_data[19],fft_data[20],fft_data[21],fft_data[22],fft_data[23],fft_data[24],fft_data[25]}
      params.scale = InFVScale:GetValue(req).Value
      params.smooth = InFVSmooth:GetValue(req).Value
      params.cd     = InFVCD:GetValue(req).Value
      params.alpha  = InFVAlpha:GetValue(req).Value
      params.compOrder = 15                   -- params.srcCompOrder = src:IsMask() and 1 or 15
      params.width  = img.DataWindow:Width()
      params.height = img.DataWindow:Height()
      params.itime = req.Time / framerate
      node:SetParamBlock(params)
    end


    node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)

    node:AddInput("src", img)
    node:AddOutput("dst", out)

    local success = node:RunSession(req)
    if not success then
        dst = nil
        dump(node:GetErrorLog()) -- Fehlerausgabe des DCTL
    end

    -- InImage
    if InChannel0:GetValue(req) ~= nil then
      local iimg = InChannel0:GetValue(req)

      local apply_modes = {
          "Merge",
          "Screen",
          "Dissolve",
          "Multiply",
          "Overlay",
          "SoftLight",
          "HardLight",
          "ColorDodge",
          "ColorBurn",
          "Darken",
          "Lighten",
          "Difference",
          "Exclusion",
          "Hue",
          "Saturation",
          "Color",
          "Luminosity",
          }
      local apply_mode = InFVMerge:GetValue(req).Value + 1
      local alpha_gain = InBkgAlpha:GetValue(req).Value

      out:Merge(iimg, {
            IMGPR_GPURequested = true,
            IMGPR_SourceReq    = req,
            MO_ApplyMode       = apply_modes[apply_mode],
            MO_ApplyOperator   = "Over",
            MO_FgAlphaGain     = alpha_gain,
            })
    end
  end




  --Shadertoy Audio - Waveform
  if (InShadertoyAudio:GetValue(req).Value == 1 and shadertoySpec[1] ~= nil) then
    for x=1, 512 do
      ptrW = math.floor(x/512*479 * windowwidth/256)+1

      xt = (513-x)/512
      xu  = math.log10(xt*0.9+0.1)+1   -- logarithmic graphs

      ptrS = math.ceil(513-xu*512)     --  math.ceil(windowwidth-xu*windowwidth)

      pS.R = shadertoySpec[ptrS] * InShaderAudioScale:GetValue(req).Value
      pW.R = ((waveform[ptrW] * scale)) + 0.5

      out2:SetPixel(x-1,0, pS) -- Spektrumpixel in der Hauptschleife
      out2:SetPixel(x-1,1, pW) -- Wavepixel

    end
  end

  if not ipc then
    lasttime = currenttime   -- due to the smoothfeature
  end


  OutImage:Set(req,out)
  OutImage2:Set(req,out2)
  collectgarbage(); -- ???
end
