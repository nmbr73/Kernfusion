--- Work in Progress !!!
--


-------------------------------------------------------------------------------------------------------------------------------------------

FuRegisterClass("CubeMapColorizer_nmbr73", CT_SourceTool, {
    REGS_Name = "CubeMap Colorizer",
	  REGS_Category = "Fuses/Kernfusion",
    REGS_OpDescription = "Colorize the faces of a CubeMap. Helps to locate them in the output (for debugging).",
	  REGS_OpIconString = "CMC",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls = true,
	  REG_TimeVariant = false,
	  REGS_Company = "nmbr73",
	  REGS_URL = "https://nmbr73.github.io/",
	  REG_Version	= 000001,
    REG_Fuse_NoEdit = false,
    REG_Fuse_NoReload = false,
    })



-------------------------------------------------------------------------------------------------------------------------------------------

ParametersCode =
[[
  float width;
  float height;
  float gain;
]]

-------------------------------------------------------------------------------------------------------------------------------------------

CompatibilityCode =
[[

#define set_color(T,X,Y,C)  _tex2DVec4Write((T), (X), (Y), (C));
#define get_color(T,X,Y)    _tex2DVecN((T),(X),(Y),15);


__DEVICE__ float4 cubemap(__TEXTURE2D__ t, float3 xyz)
{
  float ax=_fabs(xyz.x);
  float ay=_fabs(xyz.y);
  float az=_fabs(xyz.z);

  if (xyz.x>0.0f && ax>=ay && ax>=az) // +X, Face 0, right
    return _tex2DVecN(t,(-xyz.z/ax+1.0f)/8.0f + 0.5f,(xyz.y/ax+1.0f)/6.0f + (1.0f/3.0f),15);

  if (xyz.y>0.0f && ay>=ax && ay>=az) // +Y, Face 2, top
    return _tex2DVecN(t,(xyz.x/ay+1.0f)/8.0f + 0.25f,(-xyz.z/ay+1.0f)/6.0f + (2.0f/3.0f),15);

  if (xyz.z>0.0f && az>=ax && az>=ay) // +Z, Face 4, front
    return _tex2DVecN(t,(xyz.x/az+1.0f)/8.0f + 0.25f,(xyz.y/az+1.0f)/6.0f + (1.0f/3.0f),15);

  if (xyz.x<0.0f && ax>=ay && ax>=az) // -X, Face 1, left
    return _tex2DVecN(t,(xyz.z/ax+1.0f)/8.0f,(xyz.y/ax+1.0f)/6.0f + (1.0f/3.0f),15);

  if (xyz.y<0.0f && ay>=ax && ay>=az) // -Y, Face 3, bottom
    return _tex2DVecN(t,(xyz.x/ay+1.0f)/8.0f + 0.25f,(xyz.z/ay+1.0f)/6.0f,15);

  if (xyz.z<0.0f && az>=ax && az>=ay) // -Z, Face 5, back
    return _tex2DVecN(t,(-xyz.x/az+1.0f)/8.0f + 0.75f,(xyz.y/az+1.0f)/6.0f + (1.0f/3.0f),15);

  return to_float4(1.0f,0.0f,0.0f,1.0f); // error
}


]]

-------------------------------------------------------------------------------------------------------------------------------------------


KernelCode =
[[


__KERNEL__ void CubeMapColorizerKernel(
    __CONSTANTREF__ Params*   params,
    __TEXTURE2D__             input,
    __TEXTURE2D_WRITE__       output)
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);

  float w = params->width;
  float h = params->height;

  if (x >= w || y >= h)
    return;

  float u = x/w; // x normalized to 0...1
  float v = y/h; // y normalized to 0...1

  int col = int(floor(u / (1.0f / 4.0f))); // 0|1|2|3
  int row = int(floor(v / (1.0f / 3.0f))); // 0|1|2

  float4 color = get_color(input,u,v);
  float4 tinge = to_float4(0.0f,0.0f,0.0f,color.w);

  if (row == 1)
    switch (col) {
      case 0: tinge.r=1.0f; break;
      case 1: tinge.g=1.0f; break;
      case 2: tinge.b=1.0f; break;
      case 3: tinge.r=1.0f; tinge.g=1.0f; break;
    }
  else if (col == 1)
    switch (row) {
      case 0: tinge.g=1.0f; tinge.b=1.0f; break;
      case 2: tinge.r=1.0f; tinge.b=1.0f; break;
    };

  float4 colorized=mix(color,tinge,to_float4_s(params->gain));

  set_color(output, x, y, colorized);
}


]]
-- /*



-------------------------------------------------------------------------------------------------------------------------------------------

function Create()


  ----- In/Out

  InImage = self:AddInput( "Input",  "image",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })

  InGain = self:AddInput("Gain", "Gain", {
      LINKID_DataType = "Number",
      INPID_InputControl = "SliderControl",
      INP_Default = 0.5,
      })


  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })

  ----- Inspector Panel Controls

  self:AddControlPage("Image")

  InGlobalIn  = self:AddInput("Global In",  "GlobalIn",  { LINKID_DataType = "Number", })
  InGlobalOut = self:AddInput("Global Out", "GlobalOut", { LINKID_DataType = "Number", })

end



-------------------------------------------------------------------------------------------------------------------------------------------

function Process(req)

  local w  = Width
  local h  = Height
  local ax = XAspect
  local ay = YAspect
  local sd = SourceDepth

  local input = InImage:GetValue(req)

  if input ~= nil then
    w   = input.Width
    h   = input.Height
    ax  = input.XAspect
    ay  = input.YAspect
    sd  = input.SourceDepth
  end


  local output   = Image({
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = w,
    IMG_Height = h,
    IMG_XScale = ax,
    IMG_YScale = ay,
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (sd~=0) and sd or nil   )
  })



  output:Fill(Pixel({R=0,G=0,B=0,A=0}))

  if req:IsPreCalc() then
    OutImage:Set(req, Image({IMG_Like = output, IMG_NoData = true}))
    return
  end

  local node = DVIPComputeNode(req,
    "CubeMapColorizerKernel", CompatibilityCode..KernelCode,
    "Params", ParametersCode
  )

  -- Extern texture or create a new one

  if input==nil then
    input = Image({IMG_Like = output})
    input:Fill(Pixel({R=0,G=0,B=0,A=0}))
  end

  -- DCTL parameters

  local params = {}

  params = node:GetParamBlock(ParametersCode)

  params.width  = output.Width
  params.height = output.Height
  params.gain = InGain:GetValue(req).Value

  -- Set parameters and add I/O

  node:SetParamBlock(params)
  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
  node:AddInput("Image",input)
  node:AddOutput("Output", output)

  local ok = node:RunSession(req)

	if (not ok) then
		output = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,output)
end
